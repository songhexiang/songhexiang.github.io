<!doctype html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="https://github.com/songhexiang/">
<meta property="og:type" content="website">
<meta property="og:title" content="Song's Blog">
<meta property="og:url" content="http://songhexiang.github.io/index.html">
<meta property="og:site_name" content="Song's Blog">
<meta property="og:description" content="https://github.com/songhexiang/">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Song's Blog">
<meta name="twitter:description" content="https://github.com/songhexiang/">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"right","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://songhexiang.github.io/"/>





  <title> Song's Blog </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?91e43d531cb0b275d05c52f825339440";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>










  
  
    
  

  <div class="container sidebar-position-right 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Song's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">welcome to my blog</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://songhexiang.github.io/2017/04/11/malloc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hexiang Song">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://avatars0.githubusercontent.com/u/25613681?v=3&u=2ab2f40fabd733bb5be5055881caba1099fba9a6&s=400">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Song's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/11/malloc/" itemprop="url">
                  转：malloc的简易实现
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-11T16:25:03+08:00">
                2017-04-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          
             <span id="/2017/04/11/malloc/" class="leancloud_visitors" data-flag-title="转：malloc的简易实现">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>  </p><p>任何一个用过或学过C的人对malloc都不会陌生。大家都知道malloc可以分配一段连续的内存空间，并且在不再使用时可以通过free释放掉。但是，许多程序员对malloc背后的事情并不熟悉，许多人甚至把malloc当做操作系统所提供的系统调用或C的关键字。实际上，malloc只是C的标准库中提供的一个普通函数，而且实现malloc的<strong>基本</strong>思想并不复杂，任何一个对C和操作系统有些许了解的程序员都可以很容易理解。</p><p></p>
<p></p><p>这篇文章通过实现一个简单的malloc来描述malloc背后的机制。当然与现有C的标准库实现（例如glibc）相比，我们实现的malloc并不是特别高效，但是这个实现比目前真实的malloc实现要简单很多，因此易于理解。重要的是，这个实现和真实实现在基本原理上是一致的。</p><p></p>
<p></p><p>这篇文章将首先介绍一些所需的基本知识，如操作系统对进程的内存管理以及相关的系统调用，然后逐步实现一个简单的malloc。为了简单起见，这篇文章将只考虑x86_64体系结构，操作系统为Linux。</p><br><!-- toc --><p></p>
<p><ul></ul></p>
<p><li><a href="#1-什么是malloc">1 什么是malloc</a></li></p>
<p><li><a href="#2-预备知识">2 预备知识</a><ul></ul></li></p>
<p><li><a href="#21-linux内存管理">2.1 Linux内存管理</a><ul></ul></li></p>
<p><li><a href="#211-虚拟内存地址与物理内存地址">2.1.1 虚拟内存地址与物理内存地址</a></li></p>
<p><li><a href="#212-页与地址构成">2.1.2 页与地址构成</a></li></p>
<p><li><a href="#213-内存页与磁盘页">2.1.3 内存页与磁盘页</a></li><br><br></p>
<p><li><a href="#22-linux进程级内存管理">2.2 Linux进程级内存管理</a><ul></ul></li></p>
<p><li><a href="#221-内存排布">2.2.1 内存排布</a></li></p>
<p><li><a href="#222-heap内存模型">2.2.2 Heap内存模型</a></li></p>
<p><li><a href="#223-brk与sbrk">2.2.3 brk与sbrk</a></li></p>
<p><li><a href="#224-资源限制与rlimit">2.2.4 资源限制与rlimit</a></li><br><br><br><br></p>
<p><li><a href="#3-实现malloc">3 实现malloc</a><ul></ul></li></p>
<p><li><a href="#31-玩具实现">3.1 玩具实现</a></li></p>
<p><li><a href="#32-正式实现">3.2 正式实现</a><ul></ul></li></p>
<p><li><a href="#321-数据结构">3.2.1 数据结构</a></li></p>
<p><li><a href="#322-寻找合适的block">3.2.2 寻找合适的block</a></li></p>
<p><li><a href="#323-开辟新的block">3.2.3 开辟新的block</a></li></p>
<p><li><a href="#324-分裂block">3.2.4 分裂block</a></li></p>
<p><li><a href="#325-malloc的实现">3.2.5 malloc的实现</a></li></p>
<p><li><a href="#326-calloc的实现">3.2.6 calloc的实现</a></li></p>
<p><li><a href="#327-free的实现">3.2.7 free的实现</a></li></p>
<p><li><a href="#328-realloc的实现">3.2.8 realloc的实现</a></li><br><br></p>
<p><li><a href="#33-遗留问题和优化">3.3 遗留问题和优化</a></li><br><br></p>
<p><li><a href="#4-其它参考">4 其它参考</a></li><br><br><!-- toc stop --></p>
<p></p><h1 id="1-什么是malloc">1 什么是malloc</h1><p></p>
<p></p><p>在实现malloc之前，先要相对正式地对malloc做一个定义。</p><p></p>
<p></p><p>根据标准C库函数的定义，malloc具有如下原型：</p><p></p>
<p><pre class="prettyprint linenums lang-c">void* malloc(size_t size);<br></pre></p>
<p></p><p>这个函数要实现的功能是在系统中分配一段连续的可用的内存，具体有如下要求：</p><p></p>
<p><ul></ul></p>
<p><li>malloc分配的内存大小<strong>至少</strong>为size参数所指定的字节数</li></p>
<p><li>malloc的返回值是一个指针，指向一段可用内存的起始地址</li></p>
<p><li>多次调用malloc所分配的地址不能有重叠部分，除非某次malloc所分配的地址被释放掉</li></p>
<p><li>malloc应该尽快完成内存分配并返回（不能使用<a href="http://en.wikipedia.org/wiki/NP-hard" target="_blank" rel="external">NP-hard</a>的内存分配算法）</li></p>
<p><li>实现malloc时应同时实现内存大小调整和内存释放函数（即realloc和free）</li><br></p>
<p></p><p>对于malloc更多的说明可以在命令行中键入以下命令查看：</p><p></p>
<p><pre class="prettyprint linenums lang-bash">man malloc<br></pre></p>
<p></p><h1 id="2-预备知识">2 预备知识</h1><p></p>
<p></p><p>在实现malloc之前，需要先解释一些Linux系统内存相关的知识。</p><p></p>
<p></p><h2 id="21-linux内存管理">2.1 Linux内存管理</h2><p></p>
<p></p><h3 id="211-虚拟内存地址与物理内存地址">2.1.1 虚拟内存地址与物理内存地址</h3><p></p>
<p></p><p>为了简单，现代操作系统在处理内存地址时，普遍采用虚拟内存地址技术。即在汇编程序（或机器语言）层面，当涉及内存地址时，都是使用虚拟内存地址。采用这种技术时，每个进程仿佛自己独享一片$2^N$字节的内存，其中$N$是机器位数。例如在64位CPU和64位操作系统下，每个进程的虚拟地址空间为$2^{64}$Byte。</p><p></p>
<p></p><p>这种虚拟地址空间的作用主要是简化程序的编写及方便操作系统对进程间内存的隔离管理，真实中的进程不太可能（也用不到）如此大的内存空间，实际能用到的内存取决于物理内存大小。</p><p></p>
<p></p><p>由于在机器语言层面都是采用虚拟地址，当实际的机器码程序涉及到内存操作时，需要根据当前进程运行的实际上下文将虚拟地址转换为物理内存地址，才能实现对真实内存数据的操作。这个转换一般由一个叫<a href="http://en.wikipedia.org/wiki/Memory_management_unit" target="_blank" rel="external">MMU</a>（Memory Management Unit）的硬件完成。</p><p></p>
<p></p><h3 id="212-页与地址构成">2.1.2 页与地址构成</h3><p></p>
<p></p><p>在现代操作系统中，不论是虚拟内存还是物理内存，都不是以字节为单位进行管理的，而是以页（Page）为单位。一个内存页是一段固定大小的连续内存地址的总称，具体到Linux中，典型的内存页大小为4096Byte（4K）。</p><p></p>
<p></p><p>所以内存地址可以分为页号和页内偏移量。下面以64位机器，4G物理内存，4K页大小为例，虚拟内存地址和物理内存地址的组成如下：</p><p></p>
<p></p><p><img src="http://blog-codinglabs-org.qiniudn.com/image/a-malloc-tutorial-01.png" alt="内存地址构成"></p><p></p>
<p></p><p>上面是虚拟内存地址，下面是物理内存地址。由于页大小都是4K，所以页内偏移都是用低12位表示，而剩下的高地址表示页号。</p><p></p>
<p></p><p>MMU映射单位并不是字节，而是页，这个映射通过查一个常驻内存的数据结构<a href="http://en.wikipedia.org/wiki/Page_table" target="_blank" rel="external">页表</a>来实现。现在计算机具体的内存地址映射比较复杂，为了加快速度会引入一系列缓存和优化，例如<a href="http://en.wikipedia.org/wiki/Translation_lookaside_buffer" target="_blank" rel="external">TLB</a>等机制。下面给出一个经过简化的内存地址翻译示意图，虽然经过了简化，但是基本原理与现代计算机真实的情况的一致的。</p><p></p>
<p></p><p><img src="http://blog-codinglabs-org.qiniudn.com/image/a-malloc-tutorial-02.png" alt="内存地址翻译"></p><p></p>
<p></p><h3 id="213-内存页与磁盘页">2.1.3 内存页与磁盘页</h3><p></p>
<p></p><p>我们知道一般将内存看做磁盘的的缓存，有时MMU在工作时，会发现页表表明某个内存页不在物理内存中，此时会触发一个缺页异常（Page Fault），此时系统会到磁盘中相应的地方将磁盘页载入到内存中，然后重新执行由于缺页而失败的机器指令。关于这部分，因为可以看做对malloc实现是透明的，所以不再详细讲述，有兴趣的可以参考《深入理解计算机系统》相关章节。</p><p></p>
<p></p><p>最后附上一张在维基百科找到的更加符合真实地址翻译的流程供大家参考，这张图加入了TLB和缺页异常的流程（<a href="http://en.wikipedia.org/wiki/Page_table" target="_blank" rel="external">图片来源页</a>）。</p><p></p>
<p></p><p><img src="http://blog-codinglabs-org.qiniudn.com/image/a-malloc-tutorial-03.png" alt="较为完整的地址翻译流程"></p><p></p>
<p></p><h2 id="22-linux进程级内存管理">2.2 Linux进程级内存管理</h2><p></p>
<p></p><h3 id="221-内存排布">2.2.1 内存排布</h3><p></p>
<p></p><p>明白了虚拟内存和物理内存的关系及相关的映射机制，下面看一下具体在一个进程内是如何排布内存的。</p><p></p>
<p></p><p>以Linux 64位系统为例。理论上，64bit内存地址可用空间为0x0000000000000000 ~ 0xFFFFFFFFFFFFFFFF，这是个相当庞大的空间，Linux实际上只用了其中一小部分（256T）。</p><p></p>
<p></p><p>根据<a href="https://www.kernel.org/doc/Documentation/x86/x86_64/mm.txt" target="_blank" rel="external">Linux内核相关文档</a>描述，Linux64位操作系统仅使用低47位，高17位做扩展（只能是全0或全1）。所以，实际用到的地址为空间为0x0000000000000000 ~ 0x00007FFFFFFFFFFF和0xFFFF800000000000 ~ 0xFFFFFFFFFFFFFFFF，其中前面为用户空间（User Space），后者为内核空间（Kernel Space）。图示如下：</p><p></p>
<p></p><p><img src="http://blog-codinglabs-org.qiniudn.com/image/a-malloc-tutorial-04.png" alt="Linux进程地址排布"></p><p></p>
<p></p><p>对用户来说，主要关注的空间是User Space。将User Space放大后，可以看到里面主要分为如下几段：</p><p></p>
<p><ul></ul></p>
<p><li>Code：这是整个用户空间的最低地址部分，存放的是指令（也就是程序所编译成的可执行机器码）</li></p>
<p><li>Data：这里存放的是初始化过的全局变量</li></p>
<p><li>BSS：这里存放的是未初始化的全局变量</li></p>
<p><li>Heap：堆，这是我们本文重点关注的地方，堆自低地址向高地址增长，后面要讲到的brk相关的系统调用就是从这里分配内存</li></p>
<p><li>Mapping Area：这里是与mmap系统调用相关的区域。大多数实际的malloc实现会考虑通过mmap分配较大块的内存区域，本文不讨论这种情况。这个区域自高地址向低地址增长</li></p>
<p><li>Stack：这是栈区域，自高地址向低地址增长</li><br></p>
<p></p><p>下面我们主要关注Heap区域的操作。对整个Linux内存排布有兴趣的同学可以参考其它资料。</p><p></p>
<p></p><h3 id="222-heap内存模型">2.2.2 Heap内存模型</h3><p></p>
<p></p><p>一般来说，malloc所申请的内存主要从Heap区域分配（本文不考虑通过mmap申请大块内存的情况）。</p><p></p>
<p></p><p>由上文知道，进程所面对的虚拟内存地址空间，只有按页映射到物理内存地址，才能真正使用。受物理存储容量限制，整个堆虚拟内存空间不可能全部映射到实际的物理内存。Linux对堆的管理示意如下：</p><p></p>
<p></p><p><img src="http://blog-codinglabs-org.qiniudn.com/image/a-malloc-tutorial-05.png" alt="Linux进程堆管理"></p><p></p>
<p></p><p>Linux维护一个break指针，这个指针指向堆空间的某个地址。从堆起始地址到break之间的地址空间为映射好的，可以供进程访问；而从break往上，是未映射的地址空间，如果访问这段空间则程序会报错。</p><p></p>
<p></p><h3 id="223-brk与sbrk">2.2.3 brk与sbrk</h3><p></p>
<p></p><p>由上文知道，要增加一个进程实际的可用堆大小，就需要将break指针向高地址移动。Linux通过brk和sbrk系统调用操作break指针。两个系统调用的原型如下：</p><p></p>
<p><pre class="prettyprint linenums lang-c">int brk(void <em>addr);<br>void </em>sbrk(intptr_t increment);<br></pre></p>
<p></p><p>brk将break指针直接设置为某个地址，而sbrk将break从当前位置移动increment所指定的增量。brk在执行成功时返回0，否则返回-1并设置errno为ENOMEM；sbrk成功时返回break移动之前所指向的地址，否则返回(void *)-1。</p><p></p>
<p></p><p>一个小技巧是，如果将increment设置为0，则可以获得当前break的地址。</p><p></p>
<p></p><p>另外需要注意的是，由于Linux是按页进行内存映射的，所以如果break被设置为没有按页大小对齐，则系统实际上会在最后映射一个完整的页，从而实际已映射的内存空间比break指向的地方要大一些。但是使用break之后的地址是很危险的（尽管也许break之后确实有一小块可用内存地址）。</p><p></p>
<p></p><h3 id="224-资源限制与rlimit">2.2.4 资源限制与rlimit</h3><p></p>
<p></p><p>系统对每一个进程所分配的资源不是无限的，包括可映射的内存空间，因此每个进程有一个rlimit表示当前进程可用的资源上限。这个限制可以通过getrlimit系统调用得到，下面代码获取当前进程虚拟内存空间的rlimit：</p><p></p>
<p><pre class="prettyprint linenums lang-c">int main() {<br>    struct rlimit <em>limit = (struct rlimit </em>)malloc(sizeof(struct rlimit));<br>    getrlimit(RLIMIT_AS, limit);<br>    printf(&quot;soft limit: %ld, hard limit: %ld\n&quot;, limit-&gt;rlim_cur, limit-&gt;rlim_max);<br>}<br></pre></p>
<p></p><p>其中rlimit是一个结构体：</p><p></p>
<p><pre class="prettyprint linenums lang-c">struct rlimit {<br>    rlim_t rlim_cur;  /<em> Soft limit </em>/<br>    rlim_t rlim_max;  /<em> Hard limit (ceiling for rlim_cur) </em>/<br>};<br></pre></p>
<p></p><p>每种资源有软限制和硬限制，并且可以通过setrlimit对rlimit进行有条件设置。其中硬限制作为软限制的上限，非特权进程只能设置软限制，且不能超过硬限制。</p><p></p>
<p></p><h1 id="3-实现malloc">3 实现malloc</h1><p></p>
<p></p><h2 id="31-玩具实现">3.1 玩具实现</h2><p></p>
<p></p><p>在正式开始讨论malloc的实现前，我们可以利用上述知识实现一个简单但几乎没法用于真实的玩具malloc，权当对上面知识的复习：</p><p></p>
<p><pre class="prettyprint linenums lang-c">/<em> 一个玩具malloc </em>/</pre></p>
<p>#include &lt;sys/types.h&gt;</p>
<p>#include &lt;unistd.h&gt;<br>void <em>malloc(size_t size)<br>{<br>    void </em>p;<br>    p = sbrk(0);<br>    if (sbrk(size) == (void *)-1)<br>        return NULL;<br>    return p;<br>}<br></p>
<p></p><p>这个malloc每次都在当前break的基础上增加size所指定的字节数，并将之前break的地址返回。这个malloc由于对所分配的内存缺乏记录，不便于内存释放，所以无法用于真实场景。</p><p></p>
<p></p><h2 id="32-正式实现">3.2 正式实现</h2><p></p>
<p></p><p>下面严肃点讨论malloc的实现方案。</p><p></p>
<p></p><h3 id="321-数据结构">3.2.1 数据结构</h3><p></p>
<p></p><p>首先我们要确定所采用的数据结构。一个简单可行方案是将堆内存空间以块（Block）的形式组织起来，每个块由meta区和数据区组成，meta区记录数据块的元信息（数据区大小、空闲标志位、指针等等），数据区是真实分配的内存区域，并且数据区的第一个字节地址即为malloc返回的地址。</p><p></p>
<p></p><p>可以用如下结构体定义一个block：</p><p></p>
<p><pre class="prettyprint linenums lang-c">typedef struct s_block <em>t_block;<br>struct s_block {<br>    size_t size;  /</em> 数据区大小 <em>/<br>    t_block next; /</em> 指向下个块的指针 <em>/<br>    int free;     /</em> 是否是空闲块 <em>/<br>    int padding;  /</em> 填充4字节，保证meta块长度为8的倍数 <em>/<br>    char data[1]  /</em> 这是一个虚拟字段，表示数据块的第一个字节，长度不应计入meta */<br>};<br></pre></p>
<p></p><p>由于我们只考虑64位机器，为了方便，我们在结构体最后填充一个int，使得结构体本身的长度为8的倍数，以便内存对齐。示意图如下：</p><p></p>
<p></p><p><img src="http://blog-codinglabs-org.qiniudn.com/image/a-malloc-tutorial-06.png" alt="Block结构"></p><p></p>
<p></p><h3 id="322-寻找合适的block">3.2.2 寻找合适的block</h3><p></p>
<p></p><p>现在考虑如何在block链中查找合适的block。一般来说有两种查找算法：</p><p></p>
<p><ul></ul></p>
<p><li><strong>First fit</strong>：从头开始，使用第一个数据区大小大于要求size的块所谓此次分配的块</li></p>
<p><li><strong>Best fit</strong>：从头开始，遍历所有块，使用数据区大小大于size且差值最小的块作为此次分配的块</li><br></p>
<p></p><p>两种方法各有千秋，best fit具有较高的内存使用率（payload较高），而first fit具有更好的运行效率。这里我们采用first fit算法。</p><p></p>
<p><pre class="prettyprint linenums lang-c">/<em> First fit </em>/<br>t_block find_block(t_block <em>last, size_t size) {<br>    t_block b = first_block;<br>    while(b &amp;&amp; !(b-&gt;free &amp;&amp; b-&gt;size &gt;= size)) {
        </em>last = b;<br>        b = b-&gt;next;<br>    }<br>    return b;<br>}<br></pre></p>
<p></p><p>find_block从frist_block开始，查找第一个符合要求的block并返回block起始地址，如果找不到这返回NULL。这里在遍历时会更新一个叫last的指针，这个指针始终指向当前遍历的block。这是为了如果找不到合适的block而开辟新block使用的，具体会在接下来的一节用到。</p><p></p>
<p></p><h3 id="323-开辟新的block">3.2.3 开辟新的block</h3><p></p>
<p></p><p>如果现有block都不能满足size的要求，则需要在链表最后开辟一个新的block。这里关键是如何只使用sbrk创建一个struct：</p><p></p>
<p><pre class="prettyprint linenums lang-c">#define BLOCK_SIZE 24 /<em> 由于存在虚拟的data字段，sizeof不能正确计算meta长度，这里手工设置 </em>/</pre></p>
<p>t_block extend_heap(t_block last, size_t s) {<br>    t_block b;<br>    b = sbrk(0);<br>    if(sbrk(BLOCK_SIZE + s) == (void *)-1)<br>        return NULL;<br>    b-&gt;size = s;<br>    b-&gt;next = NULL;<br>    if(last)<br>        last-&gt;next = b;<br>    b-&gt;free = 0;<br>    return b;<br>}<br></p>
<p></p><h3 id="324-分裂block">3.2.4 分裂block</h3><p></p>
<p></p><p>First fit有一个比较致命的缺点，就是可能会让很小的size占据很大的一块block，此时，为了提高payload，应该在剩余数据区足够大的情况下，将其分裂为一个新的block，示意如下：</p><p></p>
<p></p><p><img src="http://blog-codinglabs-org.qiniudn.com/image/a--tutorial-07.png" alt="分裂block"></p><p></p>
<p></p><p>实现代码：</p><p></p>
<p><pre class="prettyprint linenums lang-c">void split_block(t_block b, size_t s) {<br>    t_block new;<br>    new = b-&gt;data + s;<br>    new-&gt;size = b-&gt;size - s - BLOCK_SIZE ;<br>    new-&gt;next = b-&gt;next;<br>    new-&gt;free = 1;<br>    b-&gt;size = s;<br>    b-&gt;next = new;<br>}<br></pre></p>
<p></p><h3 id="325-malloc的实现">3.2.5 malloc的实现</h3><p></p>
<p></p><p>有了上面的代码，我们可以利用它们整合成一个简单但初步可用的malloc。注意首先我们要定义个block链表的头first_block，初始化为NULL；另外，我们需要剩余空间至少有BLOCK_SIZE + 8才执行分裂操作。</p><p></p>
<p></p><p>由于我们希望malloc分配的数据区是按8字节对齐，所以在size不为8的倍数时，我们需要将size调整为大于size的最小的8的倍数：</p><p></p>
<p><pre class="prettyprint linenums lang-c">size_t align8(size_t s) {<br>    if(s &amp; 0x7 == 0)<br>        return s;<br>    return ((s &gt;&gt; 3) + 1) &lt;&lt; 3;<br>}<br></pre></p>
<p><pre class="prettyprint linenums lang-c">#define BLOCK_SIZE 24<br>void *first_block=NULL;</pre></p>
<p>/<em> other functions… </em>/</p>
<p>void <em>malloc(size_t size) {<br>    t_block b, last;<br>    size_t s;<br>    /</em> 对齐地址 <em>/<br>    s = align8(size);<br>    if(first_block) {<br>        /</em> 查找合适的block <em>/<br>        last = first_block;<br>        b = find_block(&amp;last, s);<br>        if(b) {<br>            /</em> 如果可以，则分裂 <em>/<br>            if ((b-&gt;size - s) &gt;= ( BLOCK_SIZE + 8))<br>                split_block(b, s);<br>            b-&gt;free = 0;<br>        } else {<br>            /</em> 没有合适的block，开辟一个新的 */<br>            b = extend_heap(last, s);<br>            if(!b)<br>                return NULL;<br>        }<br>    } else {<br>        b = extend_heap(NULL, s);<br>        if(!b)<br>            return NULL;<br>        first_block = b;<br>    }<br>    return b-&gt;data;<br>}<br></p>
<p></p><h3 id="326-calloc的实现">3.2.6 calloc的实现</h3><p></p>
<p></p><p>有了malloc，实现calloc只要两步：</p><p></p>
<ol><br><li>malloc一段内存</li><br><li>将数据区内容置为0</li><br></ol><br><p>由于我们的数据区是按8字节对齐的，所以为了提高效率，我们可以每8字节一组置0，而不是一个一个字节设置。我们可以通过新建一个size_t指针，将内存区域强制看做size_t类型来实现。</p><br><pre class="prettyprint linenums lang-c">void <em>calloc(size_t number, size_t size) {<br>    size_t </em>new;<br>    size_t s8, i;<br>    new = malloc(number <em> size);<br>    if(new) {<br>        s8 = align8(number </em> size) &gt;&gt; 3;<br>        for(i = 0; i &lt; s8; i++)<br>            new[i] = 0;<br>    }<br>    return new;<br>}<br></pre><br><h3 id="327-free的实现">3.2.7 free的实现</h3><br><p>free的实现并不像看上去那么简单，这里我们要解决两个关键问题：</p><br><ol><br><li>如何验证所传入的地址是有效地址，即确实是通过malloc方式分配的数据区首地址</li><br><li>如何解决碎片问题</li><br></ol><br><p>首先我们要保证传入free的地址是有效的，这个有效包括两方面：</p><br><ul><br><li>地址应该在之前malloc所分配的区域内，即在first_block和当前break指针范围内</li><br><li>这个地址确实是之前通过我们自己的malloc分配的</li><br></ul><br><p>第一个问题比较好解决，只要进行地址比较就可以了，关键是第二个问题。这里有两种解决方案：一是在结构体内埋一个magic number字段，free之前通过相对偏移检查特定位置的值是否为我们设置的magic number，另一种方法是在结构体内增加一个magic pointer，这个指针指向数据区的第一个字节（也就是在合法时free时传入的地址），我们在free前检查magic pointer是否指向参数所指地址。这里我们采用第二种方案：</p><br><p>首先我们在结构体中增加magic pointer（同时要修改BLOCK_SIZE）：</p><br><pre class="prettyprint linenums lang-c">typedef struct s_block <em>t_block;<br>struct s_block {<br>    size_t size;  /</em> 数据区大小 <em>/<br>    t_block next; /</em> 指向下个块的指针 <em>/<br>    int free;     /</em> 是否是空闲块 <em>/<br>    int padding;  /</em> 填充4字节，保证meta块长度为8的倍数 <em>/<br>    void </em>ptr;    /<em> Magic pointer，指向data </em>/<br>    char data[1]  /<em> 这是一个虚拟字段，表示数据块的第一个字节，长度不应计入meta </em>/<br>};<br></pre><br><p>然后我们定义检查地址合法性的函数：</p><br><pre class="prettyprint linenums lang-c">t_block get_block(void <em>p) {<br>    char </em>tmp;<br>    tmp = p;<br>    return (p = tmp -= BLOCK_SIZE);<br>}<br><br>int valid_addr(void <em>p) {<br>    if(first_block) {<br>        if(p &gt; first_block &amp;&amp; p &lt; sbrk(0)) {<br>            return p == (get_block(p))-&gt;ptr;<br>        }<br>    }<br>    return 0;<br>}<br></em></pre><br><p>当多次malloc和free后，整个内存池可能会产生很多碎片block，这些block很小，经常无法使用，甚至出现许多碎片连在一起，虽然总体能满足某此malloc要求，但是由于分割成了多个小block而无法fit，这就是碎片问题。</p><br><p>一个简单的解决方式时当free某个block时，如果发现它相邻的block也是free的，则将block和相邻block合并。为了满足这个实现，需要将s_block改为双向链表。修改后的block结构如下：</p><br><pre class="prettyprint linenums lang-c">typedef struct s_block t_block;<br>struct s_block {<br>    size_t size;  /<em> 数据区大小 </em>/<br>    t_block prev; /<em> 指向上个块的指针 </em>/<br>    t_block next; /<em> 指向下个块的指针 </em>/<br>    int free;     /<em> 是否是空闲块 </em>/<br>    int padding;  /<em> 填充4字节，保证meta块长度为8的倍数 </em>/<br>    void <em>ptr;    /</em> Magic pointer，指向data <em>/<br>    char data[1]  /</em> 这是一个虚拟字段，表示数据块的第一个字节，长度不应计入meta <em>/<br>};<br></em></pre><br><p>合并方法如下：</p><br><pre class="prettyprint linenums lang-c">t_block fusion(t_block b) {<br>    if (b-&gt;next &amp;&amp; b-&gt;next-&gt;free) {<br>        b-&gt;size += BLOCK_SIZE + b-&gt;next-&gt;size;<br>        b-&gt;next = b-&gt;next-&gt;next;<br>        if(b-&gt;next)<br>            b-&gt;next-&gt;prev = b;<br>    }<br>    return b;<br>}<br></pre><br><p>有了上述方法，free的实现思路就比较清晰了：首先检查参数地址的合法性，如果不合法则不做任何事；否则，将此block的free标为1，并且在可以的情况下与后面的block进行合并。如果当前是最后一个block，则回退break指针释放进程内存，如果当前block是最后一个block，则回退break指针并设置first_block为NULL。实现如下：</p><br><pre class="prettyprint linenums lang-c">void free(void p) {<br>    t_block b;<br>    if(valid_addr(p)) {<br>        b = get_block(p);<br>        b-&gt;free = 1;<br>        if(b-&gt;prev &amp;&amp; b-&gt;prev-&gt;free)<br>            b = fusion(b-&gt;prev);<br>        if(b-&gt;next)<br>            fusion(b);<br>        else {<br>            if(b-&gt;prev)<br>                b-&gt;prev-&gt;prev = NULL;<br>            else<br>                first_block = NULL;<br>            brk(b);<br>        }<br>    }<br>}<br></pre><br><h3 id="328-realloc的实现">3.2.8 realloc的实现</h3><br><p>为了实现realloc，我们首先要实现一个内存复制方法。如同calloc一样，为了效率，我们以8字节为单位进行复制：</p><br><pre class="prettyprint linenums lang-c">void copy_block(t_block src, t_block dst) {<br>    size_t <em>sdata, </em>ddata;<br>    size_t i;<br>    sdata = src-&gt;ptr;<br>    ddata = dst-&gt;ptr;<br>    for(i = 0; (i <em> 8) &lt; src-&gt;size &amp;&amp; (i </em> 8) &lt; dst-&gt;size; i++)<br>        ddata[i] = sdata[i];<br>}<br></pre><br><p>然后我们开始实现realloc。一个简单（但是低效）的方法是malloc一段内存，然后将数据复制过去。但是我们可以做的更高效，具体可以考虑以下几个方面：</p><br><ul><br><li>如果当前block的数据区大于等于realloc所要求的size，则不做任何操作</li><br><li>如果新的size变小了，考虑split</li><br><li>如果当前block的数据区不能满足size，但是其后继block是free的，并且合并后可以满足，则考虑做合并</li><br></ul><br><p>下面是realloc的实现：</p><br><pre class="prettyprint linenums lang-c">void <em>realloc(void </em>p, size_t size) {<br>    size_t s;<br>    t_block b, new;<br>    void <em>newp;<br>    if (!p)<br>        /</em> 根据标准库文档，当p传入NULL时，相当于调用malloc <em>/<br>        return malloc(size);<br>    if(valid_addr(p)) {<br>        s = align8(size);<br>        b = get_block(p);<br>        if(b-&gt;size &gt;= s) {<br>            if(b-&gt;size - s &gt;= (BLOCK_SIZE + 8))<br>                split_block(b,s);<br>        } else {<br>            /</em> 看是否可进行合并 <em>/<br>            if(b-&gt;next &amp;&amp; b-&gt;next-&gt;free<br>                    &amp;&amp; (b-&gt;size + BLOCK_SIZE + b-&gt;next-&gt;size) &gt;= s) {<br>                fusion(b);<br>                if(b-&gt;size - s &gt;= (BLOCK_SIZE + 8))<br>                    split_block(b, s);<br>            } else {<br>                /</em> 新malloc */<br>                newp = malloc (s);<br>                if (!newp)<br>                    return NULL;<br>                new = get_block(newp);<br>                copy_block(b, new);<br>                free(p);<br>                return(newp);<br>            }<br>        }<br>        return (p);<br>    }<br>    return NULL;<br>}<br></pre><br><h2 id="33-遗留问题和优化">3.3 遗留问题和优化</h2><br><p>以上是一个较为简陋，但是初步可用的malloc实现。还有很多遗留的可能优化点，例如：</p><br><ul><br><li>同时兼容32位和64位系统</li><br><li>在分配较大快内存时，考虑使用mmap而非sbrk，这通常更高效</li><br><li>可以考虑维护多个链表而非单个，每个链表中的block大小均为一个范围内，例如8字节链表、16字节链表、24-32字节链表等等。此时可以根据size到对应链表中做分配，可以有效减少碎片，并提高查询block的速度</li><br><li>可以考虑链表中只存放free的block，而不存放已分配的block，可以减少查找block的次数，提高效率</li><br></ul><br><p>还有很多可能的优化，这里不一一赘述。下面附上一些参考文献，有兴趣的同学可以更深入研究。</p><br><h1 id="4-其它参考">4 其它参考</h1><br><ol><br><li>这篇文章大量参考了<a href="http://www.inf.udec.cl/~leo/Malloc_tutorial.pdf" target="_blank" rel="external">A malloc Tutorial</a>，其中一些图片和代码直接引用了文中的内容，这里特别指出</li><br><li><a href="http://csapp.cs.cmu.edu/" target="_blank" rel="external">Computer Systems: A Programmer&#39;s Perspective, 2/E</a>一书有许多值得参考的地方</li><br><li>关于Linux的虚拟内存模型，<a href="http://duartes.org/gustavo/blog/post/anatomy-of-a-program-in-memory/" target="_blank" rel="external">Anatomy of a Program in Memory</a>是很好的参考资料，另外作者还有一篇<a href="http://duartes.org/gustavo/blog/post/how-the-kernel-manages-your-memory/" target="_blank" rel="external">How the Kernel Manages Your Memory</a>对于Linux内核中虚拟内存管理的部分有很好的讲解</li><br><li>对于真实世界的malloc实现，可以参考<a href="http://repo.or.cz/w/glibc.git/blob/HEAD:/malloc/malloc.c" target="_blank" rel="external">glibc的实现</a></li><br><li>本文写作过程中大量参考了<a href="http://www.wikipedia.org/" target="_blank" rel="external">维基百科</a>，再次感谢这个伟大的网站，并且呼吁大家在手头允许的情况下可以适当捐助维基百科，帮助这个造福人类的系统运行下去</li><br></ol>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://songhexiang.github.io/2017/04/10/storage-type/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hexiang Song">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://avatars0.githubusercontent.com/u/25613681?v=3&u=2ab2f40fabd733bb5be5055881caba1099fba9a6&s=400">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Song's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/10/storage-type/" itemprop="url">
                  计算机存储数据的大小端字节序
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-10T20:23:50+08:00">
                2017-04-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          
             <span id="/2017/04/10/storage-type/" class="leancloud_visitors" data-flag-title="计算机存储数据的大小端字节序">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="计算机硬件的两种存储数据的方式"><a href="#计算机硬件的两种存储数据的方式" class="headerlink" title="计算机硬件的两种存储数据的方式"></a>计算机硬件的两种存储数据的方式</h2><ol>
<li>大端字节序 little endian</li>
<li>小端字节序 big endian</li>
</ol>
<p>举例来说数值0x1234使用两个字节存储，数值高位字节是0x12,数值低位字节是0x34  </p>
<ol>
<li>大端字节序：高位字节在前，低位字节在后，这是人类读取数值的方式</li>
<li>小端字节序：低位字节在前，高位字节在后，即以0x3412的形式存储</li>
</ol>
<p>同理数值0x12345678的存储方式如下表所示</p>
<table>
<thead>
<tr>
<th>存储方式</th>
<th style="text-align:center">address:0x1000</th>
<th style="text-align:center">0x1001</th>
<th style="text-align:center">0x1002</th>
<th style="text-align:center">0x1003</th>
<th style="text-align:center">0x1004</th>
<th style="text-align:center">0x1005</th>
</tr>
</thead>
<tbody>
<tr>
<td>大端存储 big endian</td>
<td style="text-align:center"></td>
<td style="text-align:center">12</td>
<td style="text-align:center">34</td>
<td style="text-align:center">56</td>
<td style="text-align:center">78</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>小端存储 little endian</td>
<td style="text-align:center"></td>
<td style="text-align:center">78</td>
<td style="text-align:center">56</td>
<td style="text-align:center">34</td>
<td style="text-align:center">12</td>
</tr>
</tbody>
</table>
<ul>
<li>大端字节序先读到数值高位字节，小端字节序先读到数值低位字节序</li>
<li>只有读取的时候才区分字节序，其他情况不用考虑   </li>
</ul>
<p>转换公式如下</p>
<pre><code>//处理器读入16位整数(大端字节序)，占两个字节
x = buffer[offset] * 256 + buf[offset+1];
x = buffer[offset] &lt;&lt; 8 | buffer[offset+1];

//处理器读入16位整数(小端字节序)，占两个字节
x = buffer[offset] + buffer[offset+1]*256;
x = buffer[offset] | (buffer[offset+1] &lt;&lt; 8);

//同理32位整数(大端字节序)
i = (data[3] &lt;&lt; 0) | (data[2] &lt;&lt; 8) | (data[1] &lt;&lt; 16) | (data[0] &lt;&lt; 24);

//32位整数(小端字节序)
i = (data[0] &lt;&lt; 0) | (data[1] &lt;&lt; 8) | (data[2] &lt;&lt; 16) | (data[3] &lt;&lt; 24);
</code></pre>
          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://songhexiang.github.io/2017/04/10/webbench/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hexiang Song">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://avatars0.githubusercontent.com/u/25613681?v=3&u=2ab2f40fabd733bb5be5055881caba1099fba9a6&s=400">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Song's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/10/webbench/" itemprop="url">
                  学习webbench需要掌握的基础知识（webbench源代码学习心得）
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-10T12:46:01+08:00">
                2017-04-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          
             <span id="/2017/04/10/webbench/" class="leancloud_visitors" data-flag-title="学习webbench需要掌握的基础知识（webbench源代码学习心得）">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="简述webbench源码思路"><a href="#简述webbench源码思路" class="headerlink" title="简述webbench源码思路"></a>简述webbench源码思路</h2><p>webench整体分为一个压测工具和一个向目标服务器发送请求消息的客户端，首先从从主体代码看起</p>
<h3 id="webbench-c"><a href="#webbench-c" class="headerlink" title="webbench.c"></a>webbench.c</h3><ul>
<li>定义了各种变量，作用代码中的注释都有讲解</li>
<li>定义了五个函数<ul>
<li>benchcore()</li>
<li>bench()</li>
<li>build_request()</li>
<li>alarm_handler()</li>
<li>usage()</li>
</ul>
</li>
</ul>
<p>接下来从主函数入口讲起</p>
<ul>
<li><p>主函数{</p>
<ol>
<li>参数处理，重点是getopt_long的使用，确实很有效经典</li>
<li>调用build_request(),建立http消息基本结构</li>
<li>返回bench() bench()函数完成了将http消息发送给服务器并接受响应消息的任务<br>}</li>
</ol>
</li>
<li><p>bench(){</p>
<ol>
<li>确认目标服务器可达，首次调用客户端向目标服务器发送消息</li>
<li>建立管道，用于父进程和子进程之间通信（子进程将运行过生成的结果传递给父进程）</li>
<li>循环fork,创建指定数量的子进程，代表相同数量的客户端</li>
<li>(1) 子进程 benchcore(); 将结果写进管道；<br>(2) 父进程 打开管道读数据；更新speed,bytes,succeed,failed;<br>}</li>
</ol>
</li>
</ul>
<p>我认为这张图很好的解释了bench函数<br><img src="https://github.com/songhexiang/windows/blob/master/webbench_song-0.0.1/image/webbench%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png" alt="image"></p>
<ul>
<li>benchcore(){   //真正的压力测试的模块<ol>
<li>打开定时器</li>
<li>与目标服务器建立TCP连接</li>
<li>while(时间到跳出循环){<ol>
<li>其中出现任何错误，failed++,返回；</li>
<li>成功后将读到的字符数量计入bytes,succeed++,返回；<br>}<br>}</li>
</ol>
</li>
</ol>
</li>
</ul>
<h2 id="关于URL"><a href="#关于URL" class="headerlink" title="关于URL"></a>关于URL</h2><p>URL(Uniform Resource Locator) 地址用于描述一个网络上的资源，<br>基本格式如下</p>
<blockquote>
<p>schema://host[:port#]/path/…/[;url-params][?query-string][#anchor]</p>
</blockquote>
<ul>
<li>scheme 指定低层使用的协议(例如：http, https, ftp)</li>
<li>host   HTTP服务器的IP地址或者域名</li>
<li>port#  HTTP服务器的默认端口是80，这种情况下端口号可以省略。如果使用了别的端口，必须指明，例如 <a href="http://www.cnblogs.com:8080/" target="_blank" rel="external">http://www.cnblogs.com:8080/</a></li>
<li>path   访问资源的路径</li>
<li>url-params   url参数</li>
<li>query-string 发送给http服务器的数据</li>
<li>anchor-      锚</li>
</ul>
<h4 id="URL实例"><a href="#URL实例" class="headerlink" title="URL实例"></a>URL实例</h4><blockquote>
<p><a href="http://www.mywebsite.com/sj/test;id=8079?name=sviergn&amp;x=true#stuff" target="_blank" rel="external">http://www.mywebsite.com/sj/test;id=8079?name=sviergn&amp;x=true#stuff</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Schema: http</div><div class="line">host: www.mywebsite.com</div><div class="line">path: /sj/test</div><div class="line">URL params: id=8079</div><div class="line">Query String: name=sviergn&amp;x=true</div><div class="line">Anchor: stuff</div></pre></td></tr></table></figure></p>
</blockquote>
<h2 id="http消息的结构"><a href="#http消息的结构" class="headerlink" title="http消息的结构"></a>http消息的结构</h2><h3 id="HTTP-Request-消息分为3部分"><a href="#HTTP-Request-消息分为3部分" class="headerlink" title="HTTP Request 消息分为3部分"></a>HTTP Request 消息分为3部分</h3><p><img src="https://github.com/songhexiang/windows/blob/master/webbench_song-0.0.1/image/http%E8%AF%B7%E6%B1%82%E6%B6%88%E6%81%AF%E7%BB%93%E6%9E%84.png" alt="image"></p>
<table>
<thead>
<tr>
<th>Name</th>
<th style="text-align:center">content</th>
</tr>
</thead>
<tbody>
<tr>
<td>requset line</td>
<td style="text-align:center">METHOD  /path-to-resource  HTTP/version-number</td>
</tr>
<tr>
<td>http header</td>
<td style="text-align:center">Header-Name-1:value</td>
</tr>
<tr>
<td></td>
<td style="text-align:center">Header-Name-2:value</td>
</tr>
<tr>
<td></td>
<td style="text-align:center">……</td>
</tr>
<tr>
<td>blank line</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>body</td>
<td style="text-align:center">Optional request body</td>
</tr>
</tbody>
</table>
<h4 id="request-line实例"><a href="#request-line实例" class="headerlink" title="request line实例"></a>request line实例</h4><blockquote>
<p>GET <a href="http://cn.bing.com/" target="_blank" rel="external">http://cn.bing.com/</a> HTTP/1.1</p>
</blockquote>
<h4 id="http-header实例"><a href="#http-header实例" class="headerlink" title="http header实例"></a>http header实例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Host: cn.bing.com</div><div class="line">Proxy-Connection: keep-alive</div><div class="line">User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/57.0.2987.133 Safari/537.36</div><div class="line">Accept: */*</div><div class="line">Referer: http://cn.bing.com/</div><div class="line">Accept-Encoding: gzip, deflate, sdch</div><div class="line">Accept-Language: zh-CN,zh;q=0.8</div></pre></td></tr></table></figure>
<h4 id="body实例"><a href="#body实例" class="headerlink" title="body实例"></a>body实例</h4><blockquote>
<p>{“id”:130970,”cateId”:”1002”} <em>注：GET方法是没有body的</em></p>
</blockquote>
<h4 id="关于METHOD中POST和GET方法的区别"><a href="#关于METHOD中POST和GET方法的区别" class="headerlink" title="关于METHOD中POST和GET方法的区别"></a>关于METHOD中POST和GET方法的区别</h4><ol>
<li>GET提交的数据会放在URL之后，以?分割URL和传输数据，参数之间以&amp;相连，如EditPosts.aspx?name=test1&amp;id=123456.  POST方法是把提交的数据放在HTTP包的Body中.</li>
<li>GET提交的数据大小有限制(因为浏览器对URL的长度有限制),而POST方法提交的数据没有限制.</li>
<li>GET方式需要使用Request.QueryString来取得变量的值,而POST方式通过Request.Form来获取变量的值.</li>
<li>GET方式提交数据,会带来安全问题,比如一个登录页面,通过GET方式提交数据时，用户名和密码将出现在URL上,如果页面可以被缓存或者其他人可以访问这台机器,就可以从历史记录获得该用户的账号和密码.</li>
</ol>
<h3 id="HTTP-Response消息也分为三部分"><a href="#HTTP-Response消息也分为三部分" class="headerlink" title="HTTP Response消息也分为三部分"></a>HTTP Response消息也分为三部分</h3><table>
<thead>
<tr>
<th>Name</th>
<th style="text-align:center">content</th>
</tr>
</thead>
<tbody>
<tr>
<td>response line</td>
<td style="text-align:center">HTTP/version-number   status_code     message</td>
</tr>
<tr>
<td>http header</td>
<td style="text-align:center">Header-Name-1:value</td>
</tr>
<tr>
<td></td>
<td style="text-align:center">Header-Name-2:value</td>
</tr>
<tr>
<td></td>
<td style="text-align:center">……</td>
</tr>
<tr>
<td>blank line</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>body</td>
<td style="text-align:center">Optional response body</td>
</tr>
</tbody>
</table>
<blockquote>
<p>Response 消息中的第一行叫做状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成。状态码用来告诉HTTP客户端，HTTP服务器是否产生了预期的Response.</p>
</blockquote>
<ul>
<li>HTTP/1.1中定义了5类状态码， 状态码由三位数字组成，第一个数字定义了响应的类别<ul>
<li>1XX  提示信息 - 表示请求已被成功接收，继续处理</li>
<li>2XX  成功 - 表示请求已被成功接收，理解，接受</li>
<li>3XX  重定向 - 要完成请求必须进行更进一步的处理</li>
<li>4XX  客户端错误 -  请求有语法错误或请求无法实现</li>
<li>5XX  服务器端错误 -   服务器未能实现合法的请求</li>
</ul>
</li>
</ul>
<h2 id="关于getopt-getopt-long参数处理函数"><a href="#关于getopt-getopt-long参数处理函数" class="headerlink" title="关于getopt getopt_long参数处理函数"></a>关于getopt getopt_long参数处理函数</h2><h3 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h3><p>在程序中一般都会用到命令行选项，我们可以使用getopt和getopt_long函数来解析命令行参数</p>
<h3 id="getopt"><a href="#getopt" class="headerlink" title="getopt"></a>getopt</h3><p>getopt主要用于处理短命令行选项，例如 ./test -v 中-v就是一个短命令行选项。<br>使用该函数需要引入头文件<unistd.h>,以下是getopt函数的定义<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">#include &lt;unistd.h&gt;</div><div class="line">extern char *optarg;  //选项的参数指针，存放选项对应的输入参数  </div><div class="line">extern int optind;   //下一次调用getopt时，从optind存储的位置处重新开始检查选项。   </div><div class="line">extern int opterr;  //当opterr=0时，getopt不向stderr输出错误信息。  </div><div class="line">extern int optopt;  //当命令行选项字符不包括在optstring中或者最后一个选项缺少必要的参数时，该选项存储在optopt中，getopt返回&apos;？’</div><div class="line"></div><div class="line">int getopt(int argc, char * const argv[], const char * optstring);</div></pre></td></tr></table></figure></unistd.h></p>
<p>其中argc和argv是main函数中传递参数和内容，optstring用来指定可以处理哪些选项，<br>字符串optstring可以下列元素</p>
<ol>
<li>单个字符，表示选项，没有参数，optarg=NULL.</li>
<li>单个字符后接一个冒号：表示该选项后必须跟一个参数。参数紧跟在选项后或者以空格隔开。该参数的指针赋给optarg。</li>
<li>单个字符后跟两个冒号，表示该选项后必须跟一个参数。参数必须紧跟在选项后不能以空格隔开。该参数的指针赋给optarg。（这个特性是GNU的扩张）。<br>下面是optstring的一个实例：<blockquote>
<p>“a:bc::”</p>
</blockquote>
</li>
</ol>
<p>该示例表明程序可以接受三个选项：-a -b -c，其中a后面的:表示该选项后面要跟一个参数，例如./test -a text的形式，c后面的::表示该选项后面要跟一个参数且中间不准有空格，例如./test -ctext，选项后面跟的参数会被保存到optarg变量中。下面一段代码是该函数的使用实例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;unistd.h&gt;</div><div class="line"></div><div class="line">int main(int argc,char * argv[])</div><div class="line">&#123;</div><div class="line">    int ch;</div><div class="line">    while((ch = getopt(argc, argv, &quot;a:bc::&quot;)) != -1)&#123;</div><div class="line">        switch (ch) &#123;</div><div class="line">            case &apos;a&apos;:</div><div class="line">                printf(&quot;option a: %s\n&quot;,optarg);</div><div class="line">                break;</div><div class="line">            case &apos;b&apos;:</div><div class="line">                printf(&quot;option b: %s\n&quot;,optarg);</div><div class="line">                break;</div><div class="line">            case &apos;c&apos;:</div><div class="line">                printf(&quot;option c: %s\n&quot;,optarg);</div><div class="line">                break;</div><div class="line">            case &apos;d&apos;:</div><div class="line">                printf(&quot;unknown option\n&quot;);</div><div class="line">                break;</div><div class="line">            default:</div><div class="line">                printf(&quot;unknown option\n&quot;);</div><div class="line">                break;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="getopt-long"><a href="#getopt-long" class="headerlink" title="getopt_long"></a>getopt_long</h3><p>getopt_long() 是同时支持长选项和短选项的 getopt() 版本。它可以根据输入的option是单横线还是双横线开头来区分是短选项还是长选项。<br>以下是getopt_long的声明：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">#include &lt;getopt.h&gt;</div><div class="line">struct option&#123;    //长选项表</div><div class="line">     const char *name; //选项名，前面没有短横线，help,verbose之类</div><div class="line">     int has_arg;      //描述选项是否需要选项参数，no_argument 0 表示选项没有参数，required_argument 1 表示需要参数，optional_argument 2 选项参数可选</div><div class="line">     int *flag;  //如果这个指针为NULL，那么getopt_long()返回该结构val字段中的数值。如果该指针不为NULL，getopt_long()会使得它所指向的变量中填入val字段中的数值，并且getopt_long()返回0</div><div class="line">     int val;  </div><div class="line">&#125;;</div><div class="line">// 每个长选项在长选项表中都有一个单独条目，该条目里需要填入正确的数值。数组中最后的元素的值应该全是0。数组不需要排序，getopt_long()会进行线性搜索。</div><div class="line">int getopt_long(int argc, char * const argv[], const char *optstring, const struct option *longopts, int *longindex);</div></pre></td></tr></table></figure></p>
<p>在webbench.c中充分体现了对getopt_long的使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;unistd.h&gt;</div><div class="line">#include &lt;getopt.h&gt;</div><div class="line">#include &lt;stdlib.h&gt;</div><div class="line"></div><div class="line">#define METHOD_GET 0</div><div class="line">#define METHOD_POST 1</div><div class="line">#define METHOD_OPTIONS 2</div><div class="line">#define METHOD_TRACE 3</div><div class="line">#define PROGRAM_VERSION &quot;0.1&quot;</div><div class="line"></div><div class="line">int port = 80;</div><div class="line">int benchtime = 0;</div><div class="line">int http10 = 0;</div><div class="line">int clients = 0;</div><div class="line">int method = 0;</div><div class="line">int force = 0;</div><div class="line">int force_reload = 0;</div><div class="line"></div><div class="line">static const struct option longopts[]=</div><div class="line">&#123;</div><div class="line">    &#123;&quot;force&quot;,no_argument,&amp;force,1&#125;,</div><div class="line">    &#123;&quot;reload&quot;,no_argument,&amp;force_reload,1&#125;,</div><div class="line">    &#123;&quot;time&quot;,required_argument,NULL,&apos;t&apos;&#125;,</div><div class="line">    &#123;&quot;help&quot;,no_argument,NULL,&apos;?&apos;&#125;,</div><div class="line">    &#123;&quot;http09&quot;,no_argument,NULL,&apos;9&apos;&#125;,</div><div class="line">    &#123;&quot;http10&quot;,no_argument,NULL,&apos;1&apos;&#125;,</div><div class="line">    &#123;&quot;http11&quot;,no_argument,NULL,&apos;2&apos;&#125;,</div><div class="line">    &#123;&quot;get&quot;,no_argument,&amp;method,METHOD_GET&#125;,</div><div class="line">    &#123;&quot;post&quot;,no_argument,&amp;method,METHOD_POST&#125;,</div><div class="line">    &#123;&quot;options&quot;,no_argument,&amp;method,METHOD_OPTIONS&#125;,</div><div class="line">    &#123;&quot;trace&quot;,no_argument,&amp;method,METHOD_TRACE&#125;,</div><div class="line">    &#123;&quot;version&quot;,no_argument,NULL,&apos;V&apos;&#125;,</div><div class="line">    &#123;&quot;port&quot;,required_argument,NULL,&apos;p&apos;&#125;,</div><div class="line">    &#123;&quot;clients&quot;,required_argument,NULL,&apos;c&apos;&#125;,</div><div class="line">    &#123;&quot;NULL&quot;,0,NULL,0&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">static void usage()</div><div class="line">&#123;</div><div class="line">  fprintf(stderr,</div><div class="line">  &quot;damo [option]... URL\n&quot;</div><div class="line">  &quot;  -f|--force              Don&apos;t wait for reply from server.\n&quot;</div><div class="line">  &quot;  -r|--reload             Send reload request - Pragma: no-cache.\n&quot;</div><div class="line">  &quot;  -t|--time &lt;sec&gt;         Run benchmark for &lt;sec&gt; seconds.Default 30.\n&quot;</div><div class="line">  &quot;  -p|--port &lt;server:port&gt; Set server port for request.\n&quot;</div><div class="line">  &quot;  -c|--clients &lt;n&gt;        Run &lt;n&gt; HTTP clients at once.Default one.\n&quot;</div><div class="line">  &quot;  -9|--http09             Use HTTP/0.9 style requests.\n&quot;</div><div class="line">  &quot;  -1|--http10             Use HTTP/1.0 protocol.\n&quot;</div><div class="line">  &quot;  -2|--http11             Use HTTP/1.1 protocol.\n&quot;</div><div class="line">  &quot;  --get                   Use GET request method.\n&quot;</div><div class="line">  &quot;  --head                  Use HEAD request method.\n&quot;</div><div class="line">  &quot;  --options               Use OPTIONS request method.\n&quot;</div><div class="line">  &quot;  --trace                 Use TRACE request method.\n&quot;</div><div class="line">  &quot;  -?|-h|--help            This information.\n&quot;</div><div class="line">  &quot;  -V|--version            Display program version.\n&quot;</div><div class="line">  );</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main(int argc,char *argv[])</div><div class="line">&#123;</div><div class="line">  int options_index = 0;</div><div class="line">  int opt = 0;</div><div class="line"></div><div class="line">  if(argc == 1)</div><div class="line">  &#123;</div><div class="line">    usage();</div><div class="line">    return 2;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  while((opt = getopt_long(argc,argv,&quot;912Vfrt:p:c:?h&quot;,longopts,&amp;options_index)) != EOF)</div><div class="line">  &#123;</div><div class="line">    switch(opt)</div><div class="line">    &#123;</div><div class="line">      case  0 :  break;</div><div class="line">      case &apos;f&apos;:  force = 1; printf(&quot;I choose f\n&quot;);break;</div><div class="line">      case &apos;r&apos;:  force_reload = 1;break;</div><div class="line">      case &apos;9&apos;:  http10 = 0;break;</div><div class="line">      case &apos;1&apos;:  http10 = 1;break;</div><div class="line">      case &apos;2&apos;:  http10 = 2;break;</div><div class="line">      case &apos;V&apos;:</div><div class="line">                 printf(PROGRAM_VERSION&quot;\n&quot;);</div><div class="line">                 exit(0);</div><div class="line">      case &apos;t&apos;:</div><div class="line">                 benchtime = atoi(optarg);</div><div class="line">                 break;</div><div class="line">      case &apos;h&apos;:</div><div class="line">      case &apos;?&apos;:</div><div class="line">                 usage();return 2;break;</div><div class="line">      case &apos;c&apos;:  clients = atoi(optarg);break;</div><div class="line">      case &apos;p&apos;:  port = atoi(optarg);break;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="关于网络IPC-套接字"><a href="#关于网络IPC-套接字" class="headerlink" title="关于网络IPC:套接字"></a>关于网络IPC:套接字</h2><p>此部分基本参考APUE，有兴趣可以看看这本书</p>
<h3 id="网络进程间通信：socket-API简介"><a href="#网络进程间通信：socket-API简介" class="headerlink" title="网络进程间通信：socket API简介"></a>网络进程间通信：socket API简介</h3><p>不同计算机（通过网络相连）上运行的进程相互通信机制称为网络进程间通信（network IPC）。</p>
<p>在本地可以通过进程PID来唯一标识一个进程，但是在网络中这是行不通的。其实TCP/IP协议族已经帮我们解决了这个问题，网络层的“ip地址”可以唯一标识网络中的主机，而传输层的“协议+端口”可以唯一标识主机中的应用程序（进程）。这样利用三元组（ip地址，协议，端口）构成套接字，就可以标识网络的进程了，网络中的进程通信就可以利用这个标志与其它进程进行交互。</p>
<p>几个定义</p>
<ol>
<li>IP地址：即依照TCP/IP协议分配给本地主机的网络地址，两个进程要通讯，任一进程首先要知道通讯对方的位置，即对方的IP。</li>
<li>端口号：用来辨别本地通讯进程，一个本地的进程在通讯时均会占用一个端口号，不同的进程端口号不同，因此在通讯前必须要分配一个没有被访问的端口号。</li>
<li>连接：指两个进程间的通讯链路。</li>
<li>半相关：网络中用一个三元组可以在全局唯一标志一个进程：（协议，本地地址，本地端口号）这样一个三元组，叫做一个半相关,它指定连接的每半部分。</li>
<li>全相关：一个完整的网间进程通信需要由两个进程组成，并且只能使用同一种高层协议。也就是说，不可能通信的一端用TCP协议，而另一端用UDP协议。因此一个完整的网间通信需要一个五元组来标识：（协议，本地地址，本地端口号，远地地址，远地端口号），这样一个五元组，叫做一个相关（association），即两个协议相同的半相关才能组合成一个合适的相关，或完全指定组成一连接。</li>
</ol>
<h3 id="套接字描述符"><a href="#套接字描述符" class="headerlink" title="套接字描述符"></a>套接字描述符</h3><p>套接字是端点的抽象。与应用进程要使用文件描述符访问文件一样，访问套接字也需要用套接字描述符。套接字描述符在UNIX系统中是用文件描述符实现的。</p>
<p>要创建一个套接字，可以调用socket函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#include &lt;sys/socket.h&gt;</div><div class="line">int socket(int domain, int type, int protocol);</div></pre></td></tr></table></figure></p>
<table>
<thead>
<tr>
<th>参数</th>
<th style="text-align:left">类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>domain：socket通信域</td>
<td style="text-align:left">AF_INET IPV4 默认 IPPROTO_TCP 因特网域</td>
</tr>
<tr>
<td></td>
<td style="text-align:left">AF_INET6 IPV6因特网域</td>
</tr>
<tr>
<td></td>
<td style="text-align:left">AF_UNIX UNIX域  同 AF_LOCAL</td>
</tr>
<tr>
<td></td>
<td style="text-align:left">AF_UNSPEC 未指定</td>
</tr>
<tr>
<td>type: socket类型</td>
<td style="text-align:left">SOCK_STREAM 有序，可靠，双向的面向连接字节流  在AF_INET域中默认IPPROTO_TCP</td>
</tr>
<tr>
<td></td>
<td style="text-align:left">SOCK_DGRAM 长度固定的，无连接的不可靠报文传递 在AF_INET域中默认IPPROTO_UDP</td>
</tr>
<tr>
<td></td>
<td style="text-align:left">SOCK_RAW IP协议的数据包接口（POSIX1中为可选）</td>
</tr>
<tr>
<td></td>
<td style="text-align:left">SOCK_SEQPACKET 长度固定有序可靠地面向连接的报文传递</td>
</tr>
<tr>
<td>protocol：指定协议</td>
<td style="text-align:left">IPPROTO_TCP  TCP传输协议</td>
</tr>
<tr>
<td></td>
<td style="text-align:left">IPPROTO_UDP  UDP传输协议</td>
</tr>
<tr>
<td></td>
<td style="text-align:left">IPPROTO_ICMP</td>
</tr>
<tr>
<td></td>
<td style="text-align:left">IPPROTO_IP</td>
</tr>
<tr>
<td></td>
<td style="text-align:left">IPPROTO_IPV6</td>
</tr>
<tr>
<td></td>
<td style="text-align:left">IPPROTO_RAW  原始IP数据包协议</td>
</tr>
</tbody>
</table>
<h3 id="地址格式"><a href="#地址格式" class="headerlink" title="地址格式"></a>地址格式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">#include &lt;netinet/in.h&gt;</div><div class="line">struct in_addr &#123;</div><div class="line">    in_addr_t       s_addr; //IPV4 address</div><div class="line">&#125;;</div><div class="line"></div><div class="line">struct sockaddr_in &#123;</div><div class="line">    sa_family_t     sin_family; // address family</div><div class="line">    in_port_t       sin_port;   // port number</div><div class="line">    struct in_addr  sin_addr;   // IPV4 address</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h4 id="将套接字和地址绑定"><a href="#将套接字和地址绑定" class="headerlink" title="将套接字和地址绑定"></a>将套接字和地址绑定</h4><p>此段内容与源码关系不大，仅作了解即可<br>与客户端的套接字关联的地址意义不大，可以让系统选择一个默认的地址。然而，对于服务器，需要给一个接收客户端请求的套接字绑定一个众所周知的地址。客户端应有一种方法用以连接服务器的地址，最简单的方法就是为服务器保留一个地址并且在/etc/services或某个名字服务（name service）中注册。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">#include &lt;sys/types.h&gt;       </div><div class="line">#include &lt;sys/socket.h&gt;</div><div class="line">int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</div></pre></td></tr></table></figure></p>
<p>参数：</p>
<ul>
<li>第一个参数：bind()函数把一个地址族中的特定地址赋给该sockfd（套接字描述字）。例如对应AF_INET、AF_INET6就是把一个ipv4或ipv6地址和端口号组合赋给socket。</li>
<li>struct sockaddr * 指针，指向要绑定给sockfd的协议地址。这个地址结构根据地址创建socket时的地址协议族的不同而不同，上面给出了AF_INET的地址结构struct sockaddr_in</li>
<li>第三个参数：addrlen 对应的是地址的长度<br>返回值：</li>
<li>成功返回0，出错返回-1<br>作用：</li>
<li>将套接字与端口号绑定，即把一个ip地址和端口号组合赋给socket</li>
</ul>
<h3 id="字节序转换"><a href="#字节序转换" class="headerlink" title="字节序转换"></a>字节序转换</h3><p>同一台计算机上的进程通信时不需要考虑字节序的问题，因为同一台计算机的内部架构都是一样的，处理器支持的字节序有大端字节序，还有小端字节序。大端字节序表示最大字节地址出现在最低有效字节，小端则相反。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#include &lt;arpa/inet.h&gt;</div><div class="line">uint32_t htonl(uint32_t hostint32);    //返回值：以网络字节序表示的32位整数</div><div class="line">uint32_t htons(uint16_t hostint16);    //返回值：以网络字节序表示的16位整数</div><div class="line">uint32_t ntohl(uint32_t hostint32);    //返回值：以主机字节序表示的32位整数</div><div class="line">uint32_t ntohs(uint16_t hostint16);    //返回值：以主机字节序表示的32位整数</div></pre></td></tr></table></figure></p>
<h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><p>如果是面向连接的网络服务，在开始交换数据前，都要在请求服务的进程套接字（客户端）和提供服务的进程套接字（服务器）之间建立一个连接，使用connect函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">#include &lt;sys/types.h&gt;       </div><div class="line">#include &lt;sys/socket.h&gt;</div><div class="line">int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</div></pre></td></tr></table></figure></p>
<p>参数：</p>
<ul>
<li>第一个参数sockfd为客户端的socket描述字</li>
<li>第二参数为服务器的socket地址</li>
<li>第三个参数为socket地址的长度。　</li>
</ul>
<p>返回值：</p>
<ul>
<li>成功返回0，出错返回-1</li>
</ul>
<p>作用：</p>
<ul>
<li>客户端通过调用connect函数来建立与TCP服务器的连接</li>
</ul>
<p><em>注意：在connect中所指定的地址是想与之通信的服务器地址。如果sockfd没有绑定到一个地址，connect会给调用者绑定一个默认地址！</em></p>
<h3 id="数据传输"><a href="#数据传输" class="headerlink" title="数据传输"></a>数据传输</h3><p>既然套接字端点表示文件描述符，那么只要建立连接，就可以使用write和read来通过套接字通信了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">#include &lt;unistd.h&gt;</div><div class="line">ssize_t write(int fd, const void *buf, size_t count);</div><div class="line">ssize_t read(int fd, void *buf, size_t count);</div></pre></td></tr></table></figure></p>
<ul>
<li><p>write()会把指针buf所指的内存写入count个字节到参数fd所指的文件内（文件读写位置也会随之移动），如果顺利write()会返回实际写入的字节数。当有错误发生时则返回-1，错误代码存入errno中！</p>
</li>
<li><p>read()会把参数fd所指的文件传送nbyte个字节到buf指针所指的内存中，成功返回读取的字节数，出错返回-1并设置errno，如果在调read之前已到达文件末尾，则这次read返回0 。</p>
</li>
</ul>
<h3 id="关闭套接字描述符"><a href="#关闭套接字描述符" class="headerlink" title="关闭套接字描述符"></a>关闭套接字描述符</h3><p>close函数用于关闭文件描述符<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#include &lt;unistd.h&gt;</div><div class="line">int close(int fd);</div></pre></td></tr></table></figure></p>
<p><em>注意：close操作只是让相应socket描述符的引用计数-1，只有引用计数为0的时候，才会触发TCP客户端向服务器端发送终止连接请求</em></p>
<h3 id="基于TCP的socket通信的基本流程"><a href="#基于TCP的socket通信的基本流程" class="headerlink" title="基于TCP的socket通信的基本流程"></a>基于TCP的socket通信的基本流程</h3><ol>
<li>TCP服务器端依次调用socket(),bind(),listen()之后，就会监听指定的socket地址了</li>
<li>TCP客户端依次调用socket(),connect()之后就向TCP服务器端发送一个连接请求</li>
<li>TCP服务器监听到这个请求后，就会调用accept()函数去接受请求，这样连接就建立好了</li>
<li>之后就可以开始网络IO操作了，类似普通文件的读写IO操作</li>
</ol>
<p><img src="https://github.com/songhexiang/windows/blob/master/webbench_song-0.0.1/image/%E5%9F%BA%E4%BA%8ETCP%E7%9A%84socket%E9%80%9A%E4%BF%A1%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B.png" alt="image"></p>
<h3 id="基于UDP的socket通信的基本流程"><a href="#基于UDP的socket通信的基本流程" class="headerlink" title="基于UDP的socket通信的基本流程"></a>基于UDP的socket通信的基本流程</h3><p><img src="https://github.com/songhexiang/windows/blob/master/webbench_song-0.0.1/image/%E5%9F%BA%E4%BA%8EUDP%E7%9A%84socket%E9%80%9A%E4%BF%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B.png" alt="image"></p>
<p>UDP协议面对无连接的通信，所以UDP没有建立连接的过程！<br>创建一个基于udp通信协议的套接字，使用socket函数时第二个参数不能传递SOCK_STREAM,而是传递SOCK_DGRAM<br>比如创建一个基于IPV4地址族的UDP套接字：socket(AF_INET,SOCK_DGRAM,0);<br>通常用于基于UDP协议的IO一般使用recvfrom()和sendto()两个函数进行数据收发。</p>
<p>部分参考： <a href="http://www.cnblogs.com/Lynn-Zhang/p/5716078.html" target="_blank" rel="external">http://www.cnblogs.com/Lynn-Zhang/p/5716078.html</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://songhexiang.github.io/2017/04/10/hello-hexo/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hexiang Song">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://avatars0.githubusercontent.com/u/25613681?v=3&u=2ab2f40fabd733bb5be5055881caba1099fba9a6&s=400">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Song's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2017/04/10/hello-hexo/" itemprop="url">
                  Hello hexo
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-10T12:28:07+08:00">
                2017-04-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          
             <span id="/2017/04/10/hello-hexo/" class="leancloud_visitors" data-flag-title="Hello hexo">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="https://avatars0.githubusercontent.com/u/25613681?v=3&u=2ab2f40fabd733bb5be5055881caba1099fba9a6&s=400"
               alt="Hexiang Song" />
          <p class="site-author-name" itemprop="name">Hexiang Song</p>
           
              <p class="site-description motion-element" itemprop="description">https://github.com/songhexiang/</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">4</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">3</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/songhexiang" target="_blank" title="Github">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  Github
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hexiang Song</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  








  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  


  




	





  





  





  






  





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("17IaRMgYmmmQsf9jVtpSIYmu-gzGzoHsz", "k3UXJpGlFu3bK8YqKaOBLTkl");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  

  

</body>
</html>
