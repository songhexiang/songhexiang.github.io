<!doctype html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="C," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="学习webbench需要掌握的基础知识（webbench源代码学习心得）简述webbench源码思路webench整体分为一个压测工具和一个向目标服务器发送请求消息的客户端，首先从从主体代码看起 webbench.c 定义了各种变量，作用代码中的注释都有讲解 定义了五个函数 benchcore() bench() build_request() alarm_handler() usage()">
<meta name="keywords" content="C">
<meta property="og:type" content="article">
<meta property="og:title" content="webbench">
<meta property="og:url" content="http://songhexiang.github.io/2017/04/10/webbench/index.html">
<meta property="og:site_name" content="Song's Blog">
<meta property="og:description" content="学习webbench需要掌握的基础知识（webbench源代码学习心得）简述webbench源码思路webench整体分为一个压测工具和一个向目标服务器发送请求消息的客户端，首先从从主体代码看起 webbench.c 定义了各种变量，作用代码中的注释都有讲解 定义了五个函数 benchcore() bench() build_request() alarm_handler() usage()">
<meta property="og:image" content="https://github.com/songhexiang/windows/blob/master/webbench_song-0.0.1/image/webbench%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png">
<meta property="og:image" content="https://github.com/songhexiang/windows/blob/master/webbench_song-0.0.1/image/http%E8%AF%B7%E6%B1%82%E6%B6%88%E6%81%AF%E7%BB%93%E6%9E%84.png">
<meta property="og:image" content="https://github.com/songhexiang/windows/blob/master/webbench_song-0.0.1/image/%E5%9F%BA%E4%BA%8ETCP%E7%9A%84socket%E9%80%9A%E4%BF%A1%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B.png">
<meta property="og:image" content="https://github.com/songhexiang/windows/blob/master/webbench_song-0.0.1/image/%E5%9F%BA%E4%BA%8EUDP%E7%9A%84socket%E9%80%9A%E4%BF%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B.png">
<meta property="og:updated_time" content="2017-04-10T08:02:53.432Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="webbench">
<meta name="twitter:description" content="学习webbench需要掌握的基础知识（webbench源代码学习心得）简述webbench源码思路webench整体分为一个压测工具和一个向目标服务器发送请求消息的客户端，首先从从主体代码看起 webbench.c 定义了各种变量，作用代码中的注释都有讲解 定义了五个函数 benchcore() bench() build_request() alarm_handler() usage()">
<meta name="twitter:image" content="https://github.com/songhexiang/windows/blob/master/webbench_song-0.0.1/image/webbench%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"right","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://songhexiang.github.io/2017/04/10/webbench/"/>





  <title> webbench | Song's Blog </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?91e43d531cb0b275d05c52f825339440";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>










  
  
    
  

  <div class="container sidebar-position-right page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Song's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">welcome to my blog</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://songhexiang.github.io/2017/04/10/webbench/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Hexiang Song">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://avatars0.githubusercontent.com/u/25613681?v=3&u=2ab2f40fabd733bb5be5055881caba1099fba9a6&s=400">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Song's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                webbench
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-10T12:46:01+08:00">
                2017-04-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          
             <span id="/2017/04/10/webbench/" class="leancloud_visitors" data-flag-title="webbench">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数 </span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="学习webbench需要掌握的基础知识（webbench源代码学习心得）"><a href="#学习webbench需要掌握的基础知识（webbench源代码学习心得）" class="headerlink" title="学习webbench需要掌握的基础知识（webbench源代码学习心得）"></a>学习webbench需要掌握的基础知识（webbench源代码学习心得）</h1><h2 id="简述webbench源码思路"><a href="#简述webbench源码思路" class="headerlink" title="简述webbench源码思路"></a>简述webbench源码思路</h2><p>webench整体分为一个压测工具和一个向目标服务器发送请求消息的客户端，首先从从主体代码看起</p>
<h3 id="webbench-c"><a href="#webbench-c" class="headerlink" title="webbench.c"></a>webbench.c</h3><ul>
<li>定义了各种变量，作用代码中的注释都有讲解</li>
<li>定义了五个函数<ul>
<li>benchcore()</li>
<li>bench()</li>
<li>build_request()</li>
<li>alarm_handler()</li>
<li>usage()</li>
</ul>
</li>
</ul>
<p>接下来从主函数入口讲起</p>
<ul>
<li><p>主函数{</p>
<ol>
<li>参数处理，重点是getopt_long的使用，确实很有效经典</li>
<li>调用build_request(),建立http消息基本结构</li>
<li>返回bench() bench()函数完成了将http消息发送给服务器并接受响应消息的任务<br>}</li>
</ol>
</li>
<li><p>bench(){</p>
<ol>
<li>确认目标服务器可达，首次调用客户端向目标服务器发送消息</li>
<li>建立管道，用于父进程和子进程之间通信（子进程将运行过生成的结果传递给父进程）</li>
<li>循环fork,创建指定数量的子进程，代表相同数量的客户端</li>
<li>(1) 子进程 benchcore(); 将结果写进管道；<br>(2) 父进程 打开管道读数据；更新speed,bytes,succeed,failed;<br>}</li>
</ol>
</li>
</ul>
<p>我认为这张图很好的解释了bench函数<br><img src="https://github.com/songhexiang/windows/blob/master/webbench_song-0.0.1/image/webbench%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png" alt="image"></p>
<ul>
<li>benchcore(){   //真正的压力测试的模块<ol>
<li>打开定时器</li>
<li>与目标服务器建立TCP连接</li>
<li>while(时间到跳出循环){<ol>
<li>其中出现任何错误，failed++,返回；</li>
<li>成功后将读到的字符数量计入bytes,succeed++,返回；<br>}<br>}</li>
</ol>
</li>
</ol>
</li>
</ul>
<h2 id="关于URL"><a href="#关于URL" class="headerlink" title="关于URL"></a>关于URL</h2><p>URL(Uniform Resource Locator) 地址用于描述一个网络上的资源，<br>基本格式如下</p>
<blockquote>
<p>schema://host[:port#]/path/…/[;url-params][?query-string][#anchor]</p>
</blockquote>
<ul>
<li>scheme 指定低层使用的协议(例如：http, https, ftp)</li>
<li>host   HTTP服务器的IP地址或者域名</li>
<li>port#  HTTP服务器的默认端口是80，这种情况下端口号可以省略。如果使用了别的端口，必须指明，例如 <a href="http://www.cnblogs.com:8080/" target="_blank" rel="external">http://www.cnblogs.com:8080/</a></li>
<li>path   访问资源的路径</li>
<li>url-params   url参数</li>
<li>query-string 发送给http服务器的数据</li>
<li>anchor-      锚</li>
</ul>
<h4 id="URL实例"><a href="#URL实例" class="headerlink" title="URL实例"></a>URL实例</h4><blockquote>
<p><a href="http://www.mywebsite.com/sj/test;id=8079?name=sviergn&amp;x=true#stuff" target="_blank" rel="external">http://www.mywebsite.com/sj/test;id=8079?name=sviergn&amp;x=true#stuff</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Schema: http</div><div class="line">host: www.mywebsite.com</div><div class="line">path: /sj/test</div><div class="line">URL params: id=8079</div><div class="line">Query String: name=sviergn&amp;x=true</div><div class="line">Anchor: stuff</div></pre></td></tr></table></figure></p>
</blockquote>
<h2 id="http消息的结构"><a href="#http消息的结构" class="headerlink" title="http消息的结构"></a>http消息的结构</h2><h3 id="HTTP-Request-消息分为3部分"><a href="#HTTP-Request-消息分为3部分" class="headerlink" title="HTTP Request 消息分为3部分"></a>HTTP Request 消息分为3部分</h3><p><img src="https://github.com/songhexiang/windows/blob/master/webbench_song-0.0.1/image/http%E8%AF%B7%E6%B1%82%E6%B6%88%E6%81%AF%E7%BB%93%E6%9E%84.png" alt="image"></p>
<table>
<thead>
<tr>
<th>Name</th>
<th style="text-align:center">content</th>
</tr>
</thead>
<tbody>
<tr>
<td>requset line</td>
<td style="text-align:center">METHOD  /path-to-resource  HTTP/version-number</td>
</tr>
<tr>
<td>http header</td>
<td style="text-align:center">Header-Name-1:value</td>
</tr>
<tr>
<td></td>
<td style="text-align:center">Header-Name-2:value</td>
</tr>
<tr>
<td></td>
<td style="text-align:center">……</td>
</tr>
<tr>
<td>blank line</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>body</td>
<td style="text-align:center">Optional request body</td>
</tr>
</tbody>
</table>
<h4 id="request-line实例"><a href="#request-line实例" class="headerlink" title="request line实例"></a>request line实例</h4><blockquote>
<p>GET <a href="http://cn.bing.com/" target="_blank" rel="external">http://cn.bing.com/</a> HTTP/1.1</p>
</blockquote>
<h4 id="http-header实例"><a href="#http-header实例" class="headerlink" title="http header实例"></a>http header实例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Host: cn.bing.com</div><div class="line">Proxy-Connection: keep-alive</div><div class="line">User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/57.0.2987.133 Safari/537.36</div><div class="line">Accept: */*</div><div class="line">Referer: http://cn.bing.com/</div><div class="line">Accept-Encoding: gzip, deflate, sdch</div><div class="line">Accept-Language: zh-CN,zh;q=0.8</div></pre></td></tr></table></figure>
<h4 id="body实例"><a href="#body实例" class="headerlink" title="body实例"></a>body实例</h4><blockquote>
<p>{“id”:130970,”cateId”:”1002”} <em>注：GET方法是没有body的</em></p>
</blockquote>
<h4 id="关于METHOD中POST和GET方法的区别"><a href="#关于METHOD中POST和GET方法的区别" class="headerlink" title="关于METHOD中POST和GET方法的区别"></a>关于METHOD中POST和GET方法的区别</h4><ol>
<li>GET提交的数据会放在URL之后，以?分割URL和传输数据，参数之间以&amp;相连，如EditPosts.aspx?name=test1&amp;id=123456.  POST方法是把提交的数据放在HTTP包的Body中.</li>
<li>GET提交的数据大小有限制(因为浏览器对URL的长度有限制),而POST方法提交的数据没有限制.</li>
<li>GET方式需要使用Request.QueryString来取得变量的值,而POST方式通过Request.Form来获取变量的值.</li>
<li>GET方式提交数据,会带来安全问题,比如一个登录页面,通过GET方式提交数据时，用户名和密码将出现在URL上,如果页面可以被缓存或者其他人可以访问这台机器,就可以从历史记录获得该用户的账号和密码.</li>
</ol>
<h3 id="HTTP-Response消息也分为三部分"><a href="#HTTP-Response消息也分为三部分" class="headerlink" title="HTTP Response消息也分为三部分"></a>HTTP Response消息也分为三部分</h3><table>
<thead>
<tr>
<th>Name</th>
<th style="text-align:center">content</th>
</tr>
</thead>
<tbody>
<tr>
<td>response line</td>
<td style="text-align:center">HTTP/version-number   status_code     message</td>
</tr>
<tr>
<td>http header</td>
<td style="text-align:center">Header-Name-1:value</td>
</tr>
<tr>
<td></td>
<td style="text-align:center">Header-Name-2:value</td>
</tr>
<tr>
<td></td>
<td style="text-align:center">……</td>
</tr>
<tr>
<td>blank line</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td>body</td>
<td style="text-align:center">Optional response body</td>
</tr>
</tbody>
</table>
<blockquote>
<p>Response 消息中的第一行叫做状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成。状态码用来告诉HTTP客户端，HTTP服务器是否产生了预期的Response.</p>
</blockquote>
<ul>
<li>HTTP/1.1中定义了5类状态码， 状态码由三位数字组成，第一个数字定义了响应的类别<ul>
<li>1XX  提示信息 - 表示请求已被成功接收，继续处理</li>
<li>2XX  成功 - 表示请求已被成功接收，理解，接受</li>
<li>3XX  重定向 - 要完成请求必须进行更进一步的处理</li>
<li>4XX  客户端错误 -  请求有语法错误或请求无法实现</li>
<li>5XX  服务器端错误 -   服务器未能实现合法的请求</li>
</ul>
</li>
</ul>
<h2 id="关于getopt-getopt-long参数处理函数"><a href="#关于getopt-getopt-long参数处理函数" class="headerlink" title="关于getopt getopt_long参数处理函数"></a>关于getopt getopt_long参数处理函数</h2><h3 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h3><p>在程序中一般都会用到命令行选项，我们可以使用getopt和getopt_long函数来解析命令行参数</p>
<h3 id="getopt"><a href="#getopt" class="headerlink" title="getopt"></a>getopt</h3><p>getopt主要用于处理短命令行选项，例如 ./test -v 中-v就是一个短命令行选项。<br>使用该函数需要引入头文件<unistd.h>,以下是getopt函数的定义<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">#include &lt;unistd.h&gt;</div><div class="line">extern char *optarg;  //选项的参数指针，存放选项对应的输入参数  </div><div class="line">extern int optind;   //下一次调用getopt时，从optind存储的位置处重新开始检查选项。   </div><div class="line">extern int opterr;  //当opterr=0时，getopt不向stderr输出错误信息。  </div><div class="line">extern int optopt;  //当命令行选项字符不包括在optstring中或者最后一个选项缺少必要的参数时，该选项存储在optopt中，getopt返回&apos;？’</div><div class="line"></div><div class="line">int getopt(int argc, char * const argv[], const char * optstring);</div></pre></td></tr></table></figure></unistd.h></p>
<p>其中argc和argv是main函数中传递参数和内容，optstring用来指定可以处理哪些选项，<br>字符串optstring可以下列元素</p>
<ol>
<li>单个字符，表示选项，没有参数，optarg=NULL.</li>
<li>单个字符后接一个冒号：表示该选项后必须跟一个参数。参数紧跟在选项后或者以空格隔开。该参数的指针赋给optarg。</li>
<li>单个字符后跟两个冒号，表示该选项后必须跟一个参数。参数必须紧跟在选项后不能以空格隔开。该参数的指针赋给optarg。（这个特性是GNU的扩张）。<br>下面是optstring的一个实例：<blockquote>
<p>“a:bc::”</p>
</blockquote>
</li>
</ol>
<p>该示例表明程序可以接受三个选项：-a -b -c，其中a后面的:表示该选项后面要跟一个参数，例如./test -a text的形式，c后面的::表示该选项后面要跟一个参数且中间不准有空格，例如./test -ctext，选项后面跟的参数会被保存到optarg变量中。下面一段代码是该函数的使用实例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;unistd.h&gt;</div><div class="line"></div><div class="line">int main(int argc,char * argv[])</div><div class="line">&#123;</div><div class="line">    int ch;</div><div class="line">    while((ch = getopt(argc, argv, &quot;a:bc::&quot;)) != -1)&#123;</div><div class="line">        switch (ch) &#123;</div><div class="line">            case &apos;a&apos;:</div><div class="line">                printf(&quot;option a: %s\n&quot;,optarg);</div><div class="line">                break;</div><div class="line">            case &apos;b&apos;:</div><div class="line">                printf(&quot;option b: %s\n&quot;,optarg);</div><div class="line">                break;</div><div class="line">            case &apos;c&apos;:</div><div class="line">                printf(&quot;option c: %s\n&quot;,optarg);</div><div class="line">                break;</div><div class="line">            case &apos;d&apos;:</div><div class="line">                printf(&quot;unknown option\n&quot;);</div><div class="line">                break;</div><div class="line">            default:</div><div class="line">                printf(&quot;unknown option\n&quot;);</div><div class="line">                break;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="getopt-long"><a href="#getopt-long" class="headerlink" title="getopt_long"></a>getopt_long</h3><p>getopt_long() 是同时支持长选项和短选项的 getopt() 版本。它可以根据输入的option是单横线还是双横线开头来区分是短选项还是长选项。<br>以下是getopt_long的声明：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">#include &lt;getopt.h&gt;</div><div class="line">struct option&#123;    //长选项表</div><div class="line">     const char *name; //选项名，前面没有短横线，help,verbose之类</div><div class="line">     int has_arg;      //描述选项是否需要选项参数，no_argument 0 表示选项没有参数，required_argument 1 表示需要参数，optional_argument 2 选项参数可选</div><div class="line">     int *flag;  //如果这个指针为NULL，那么getopt_long()返回该结构val字段中的数值。如果该指针不为NULL，getopt_long()会使得它所指向的变量中填入val字段中的数值，并且getopt_long()返回0</div><div class="line">     int val;  </div><div class="line">&#125;;</div><div class="line">// 每个长选项在长选项表中都有一个单独条目，该条目里需要填入正确的数值。数组中最后的元素的值应该全是0。数组不需要排序，getopt_long()会进行线性搜索。</div><div class="line">int getopt_long(int argc, char * const argv[], const char *optstring, const struct option *longopts, int *longindex);</div></pre></td></tr></table></figure></p>
<p>在webbench.c中充分体现了对getopt_long的使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;unistd.h&gt;</div><div class="line">#include &lt;getopt.h&gt;</div><div class="line">#include &lt;stdlib.h&gt;</div><div class="line"></div><div class="line">#define METHOD_GET 0</div><div class="line">#define METHOD_POST 1</div><div class="line">#define METHOD_OPTIONS 2</div><div class="line">#define METHOD_TRACE 3</div><div class="line">#define PROGRAM_VERSION &quot;0.1&quot;</div><div class="line"></div><div class="line">int port = 80;</div><div class="line">int benchtime = 0;</div><div class="line">int http10 = 0;</div><div class="line">int clients = 0;</div><div class="line">int method = 0;</div><div class="line">int force = 0;</div><div class="line">int force_reload = 0;</div><div class="line"></div><div class="line">static const struct option longopts[]=</div><div class="line">&#123;</div><div class="line">    &#123;&quot;force&quot;,no_argument,&amp;force,1&#125;,</div><div class="line">    &#123;&quot;reload&quot;,no_argument,&amp;force_reload,1&#125;,</div><div class="line">    &#123;&quot;time&quot;,required_argument,NULL,&apos;t&apos;&#125;,</div><div class="line">    &#123;&quot;help&quot;,no_argument,NULL,&apos;?&apos;&#125;,</div><div class="line">    &#123;&quot;http09&quot;,no_argument,NULL,&apos;9&apos;&#125;,</div><div class="line">    &#123;&quot;http10&quot;,no_argument,NULL,&apos;1&apos;&#125;,</div><div class="line">    &#123;&quot;http11&quot;,no_argument,NULL,&apos;2&apos;&#125;,</div><div class="line">    &#123;&quot;get&quot;,no_argument,&amp;method,METHOD_GET&#125;,</div><div class="line">    &#123;&quot;post&quot;,no_argument,&amp;method,METHOD_POST&#125;,</div><div class="line">    &#123;&quot;options&quot;,no_argument,&amp;method,METHOD_OPTIONS&#125;,</div><div class="line">    &#123;&quot;trace&quot;,no_argument,&amp;method,METHOD_TRACE&#125;,</div><div class="line">    &#123;&quot;version&quot;,no_argument,NULL,&apos;V&apos;&#125;,</div><div class="line">    &#123;&quot;port&quot;,required_argument,NULL,&apos;p&apos;&#125;,</div><div class="line">    &#123;&quot;clients&quot;,required_argument,NULL,&apos;c&apos;&#125;,</div><div class="line">    &#123;&quot;NULL&quot;,0,NULL,0&#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">static void usage()</div><div class="line">&#123;</div><div class="line">  fprintf(stderr,</div><div class="line">  &quot;damo [option]... URL\n&quot;</div><div class="line">  &quot;  -f|--force              Don&apos;t wait for reply from server.\n&quot;</div><div class="line">  &quot;  -r|--reload             Send reload request - Pragma: no-cache.\n&quot;</div><div class="line">  &quot;  -t|--time &lt;sec&gt;         Run benchmark for &lt;sec&gt; seconds.Default 30.\n&quot;</div><div class="line">  &quot;  -p|--port &lt;server:port&gt; Set server port for request.\n&quot;</div><div class="line">  &quot;  -c|--clients &lt;n&gt;        Run &lt;n&gt; HTTP clients at once.Default one.\n&quot;</div><div class="line">  &quot;  -9|--http09             Use HTTP/0.9 style requests.\n&quot;</div><div class="line">  &quot;  -1|--http10             Use HTTP/1.0 protocol.\n&quot;</div><div class="line">  &quot;  -2|--http11             Use HTTP/1.1 protocol.\n&quot;</div><div class="line">  &quot;  --get                   Use GET request method.\n&quot;</div><div class="line">  &quot;  --head                  Use HEAD request method.\n&quot;</div><div class="line">  &quot;  --options               Use OPTIONS request method.\n&quot;</div><div class="line">  &quot;  --trace                 Use TRACE request method.\n&quot;</div><div class="line">  &quot;  -?|-h|--help            This information.\n&quot;</div><div class="line">  &quot;  -V|--version            Display program version.\n&quot;</div><div class="line">  );</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main(int argc,char *argv[])</div><div class="line">&#123;</div><div class="line">  int options_index = 0;</div><div class="line">  int opt = 0;</div><div class="line"></div><div class="line">  if(argc == 1)</div><div class="line">  &#123;</div><div class="line">    usage();</div><div class="line">    return 2;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  while((opt = getopt_long(argc,argv,&quot;912Vfrt:p:c:?h&quot;,longopts,&amp;options_index)) != EOF)</div><div class="line">  &#123;</div><div class="line">    switch(opt)</div><div class="line">    &#123;</div><div class="line">      case  0 :  break;</div><div class="line">      case &apos;f&apos;:  force = 1; printf(&quot;I choose f\n&quot;);break;</div><div class="line">      case &apos;r&apos;:  force_reload = 1;break;</div><div class="line">      case &apos;9&apos;:  http10 = 0;break;</div><div class="line">      case &apos;1&apos;:  http10 = 1;break;</div><div class="line">      case &apos;2&apos;:  http10 = 2;break;</div><div class="line">      case &apos;V&apos;:</div><div class="line">                 printf(PROGRAM_VERSION&quot;\n&quot;);</div><div class="line">                 exit(0);</div><div class="line">      case &apos;t&apos;:</div><div class="line">                 benchtime = atoi(optarg);</div><div class="line">                 break;</div><div class="line">      case &apos;h&apos;:</div><div class="line">      case &apos;?&apos;:</div><div class="line">                 usage();return 2;break;</div><div class="line">      case &apos;c&apos;:  clients = atoi(optarg);break;</div><div class="line">      case &apos;p&apos;:  port = atoi(optarg);break;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="关于网络IPC-套接字"><a href="#关于网络IPC-套接字" class="headerlink" title="关于网络IPC:套接字"></a>关于网络IPC:套接字</h2><p>此部分基本参考APUE，有兴趣可以看看这本书</p>
<h3 id="网络进程间通信：socket-API简介"><a href="#网络进程间通信：socket-API简介" class="headerlink" title="网络进程间通信：socket API简介"></a>网络进程间通信：socket API简介</h3><p>不同计算机（通过网络相连）上运行的进程相互通信机制称为网络进程间通信（network IPC）。</p>
<p>在本地可以通过进程PID来唯一标识一个进程，但是在网络中这是行不通的。其实TCP/IP协议族已经帮我们解决了这个问题，网络层的“ip地址”可以唯一标识网络中的主机，而传输层的“协议+端口”可以唯一标识主机中的应用程序（进程）。这样利用三元组（ip地址，协议，端口）构成套接字，就可以标识网络的进程了，网络中的进程通信就可以利用这个标志与其它进程进行交互。</p>
<p>几个定义</p>
<ol>
<li>IP地址：即依照TCP/IP协议分配给本地主机的网络地址，两个进程要通讯，任一进程首先要知道通讯对方的位置，即对方的IP。</li>
<li>端口号：用来辨别本地通讯进程，一个本地的进程在通讯时均会占用一个端口号，不同的进程端口号不同，因此在通讯前必须要分配一个没有被访问的端口号。</li>
<li>连接：指两个进程间的通讯链路。</li>
<li>半相关：网络中用一个三元组可以在全局唯一标志一个进程：（协议，本地地址，本地端口号）这样一个三元组，叫做一个半相关,它指定连接的每半部分。</li>
<li>全相关：一个完整的网间进程通信需要由两个进程组成，并且只能使用同一种高层协议。也就是说，不可能通信的一端用TCP协议，而另一端用UDP协议。因此一个完整的网间通信需要一个五元组来标识：（协议，本地地址，本地端口号，远地地址，远地端口号），这样一个五元组，叫做一个相关（association），即两个协议相同的半相关才能组合成一个合适的相关，或完全指定组成一连接。</li>
</ol>
<h3 id="套接字描述符"><a href="#套接字描述符" class="headerlink" title="套接字描述符"></a>套接字描述符</h3><p>套接字是端点的抽象。与应用进程要使用文件描述符访问文件一样，访问套接字也需要用套接字描述符。套接字描述符在UNIX系统中是用文件描述符实现的。</p>
<p>要创建一个套接字，可以调用socket函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#include &lt;sys/socket.h&gt;</div><div class="line">int socket(int domain, int type, int protocol);</div></pre></td></tr></table></figure></p>
<table>
<thead>
<tr>
<th>参数</th>
<th style="text-align:left">类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>domain：socket通信域</td>
<td style="text-align:left">AF_INET IPV4 默认 IPPROTO_TCP 因特网域</td>
</tr>
<tr>
<td></td>
<td style="text-align:left">AF_INET6 IPV6因特网域</td>
</tr>
<tr>
<td></td>
<td style="text-align:left">AF_UNIX UNIX域  同 AF_LOCAL</td>
</tr>
<tr>
<td></td>
<td style="text-align:left">AF_UNSPEC 未指定</td>
</tr>
<tr>
<td>type: socket类型</td>
<td style="text-align:left">SOCK_STREAM 有序，可靠，双向的面向连接字节流  在AF_INET域中默认IPPROTO_TCP</td>
</tr>
<tr>
<td></td>
<td style="text-align:left">SOCK_DGRAM 长度固定的，无连接的不可靠报文传递 在AF_INET域中默认IPPROTO_UDP</td>
</tr>
<tr>
<td></td>
<td style="text-align:left">SOCK_RAW IP协议的数据包接口（POSIX1中为可选）</td>
</tr>
<tr>
<td></td>
<td style="text-align:left">SOCK_SEQPACKET 长度固定有序可靠地面向连接的报文传递</td>
</tr>
<tr>
<td>protocol：指定协议</td>
<td style="text-align:left">IPPROTO_TCP  TCP传输协议</td>
</tr>
<tr>
<td></td>
<td style="text-align:left">IPPROTO_UDP  UDP传输协议</td>
</tr>
<tr>
<td></td>
<td style="text-align:left">IPPROTO_ICMP</td>
</tr>
<tr>
<td></td>
<td style="text-align:left">IPPROTO_IP</td>
</tr>
<tr>
<td></td>
<td style="text-align:left">IPPROTO_IPV6</td>
</tr>
<tr>
<td></td>
<td style="text-align:left">IPPROTO_RAW  原始IP数据包协议</td>
</tr>
</tbody>
</table>
<h3 id="地址格式"><a href="#地址格式" class="headerlink" title="地址格式"></a>地址格式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">#include &lt;netinet/in.h&gt;</div><div class="line">struct in_addr &#123;</div><div class="line">    in_addr_t       s_addr; //IPV4 address</div><div class="line">&#125;;</div><div class="line"></div><div class="line">struct sockaddr_in &#123;</div><div class="line">    sa_family_t     sin_family; // address family</div><div class="line">    in_port_t       sin_port;   // port number</div><div class="line">    struct in_addr  sin_addr;   // IPV4 address</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h4 id="将套接字和地址绑定"><a href="#将套接字和地址绑定" class="headerlink" title="将套接字和地址绑定"></a>将套接字和地址绑定</h4><p>此段内容与源码关系不大，仅作了解即可<br>与客户端的套接字关联的地址意义不大，可以让系统选择一个默认的地址。然而，对于服务器，需要给一个接收客户端请求的套接字绑定一个众所周知的地址。客户端应有一种方法用以连接服务器的地址，最简单的方法就是为服务器保留一个地址并且在/etc/services或某个名字服务（name service）中注册。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">#include &lt;sys/types.h&gt;       </div><div class="line">#include &lt;sys/socket.h&gt;</div><div class="line">int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</div></pre></td></tr></table></figure></p>
<p>参数：</p>
<ul>
<li>第一个参数：bind()函数把一个地址族中的特定地址赋给该sockfd（套接字描述字）。例如对应AF_INET、AF_INET6就是把一个ipv4或ipv6地址和端口号组合赋给socket。</li>
<li>struct sockaddr * 指针，指向要绑定给sockfd的协议地址。这个地址结构根据地址创建socket时的地址协议族的不同而不同，上面给出了AF_INET的地址结构struct sockaddr_in</li>
<li>第三个参数：addrlen 对应的是地址的长度<br>返回值：</li>
<li>成功返回0，出错返回-1<br>作用：</li>
<li>将套接字与端口号绑定，即把一个ip地址和端口号组合赋给socket</li>
</ul>
<h3 id="字节序转换"><a href="#字节序转换" class="headerlink" title="字节序转换"></a>字节序转换</h3><p>同一台计算机上的进程通信时不需要考虑字节序的问题，因为同一台计算机的内部架构都是一样的，处理器支持的字节序有大端字节序，还有小端字节序。大端字节序表示最大字节地址出现在最低有效字节，小端则相反。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">#include &lt;arpa/inet.h&gt;</div><div class="line">uint32_t htonl(uint32_t hostint32);    //返回值：以网络字节序表示的32位整数</div><div class="line">uint32_t htons(uint16_t hostint16);    //返回值：以网络字节序表示的16位整数</div><div class="line">uint32_t ntohl(uint32_t hostint32);    //返回值：以主机字节序表示的32位整数</div><div class="line">uint32_t ntohs(uint16_t hostint16);    //返回值：以主机字节序表示的32位整数</div></pre></td></tr></table></figure></p>
<h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><p>如果是面向连接的网络服务，在开始交换数据前，都要在请求服务的进程套接字（客户端）和提供服务的进程套接字（服务器）之间建立一个连接，使用connect函数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">#include &lt;sys/types.h&gt;       </div><div class="line">#include &lt;sys/socket.h&gt;</div><div class="line">int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</div></pre></td></tr></table></figure></p>
<p>参数：</p>
<ul>
<li>第一个参数sockfd为客户端的socket描述字</li>
<li>第二参数为服务器的socket地址</li>
<li>第三个参数为socket地址的长度。　</li>
</ul>
<p>返回值：</p>
<ul>
<li>成功返回0，出错返回-1</li>
</ul>
<p>作用：</p>
<ul>
<li>客户端通过调用connect函数来建立与TCP服务器的连接</li>
</ul>
<p><em>注意：在connect中所指定的地址是想与之通信的服务器地址。如果sockfd没有绑定到一个地址，connect会给调用者绑定一个默认地址！</em></p>
<h3 id="数据传输"><a href="#数据传输" class="headerlink" title="数据传输"></a>数据传输</h3><p>既然套接字端点表示文件描述符，那么只要建立连接，就可以使用write和read来通过套接字通信了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">#include &lt;unistd.h&gt;</div><div class="line">ssize_t write(int fd, const void *buf, size_t count);</div><div class="line">ssize_t read(int fd, void *buf, size_t count);</div></pre></td></tr></table></figure></p>
<ul>
<li><p>write()会把指针buf所指的内存写入count个字节到参数fd所指的文件内（文件读写位置也会随之移动），如果顺利write()会返回实际写入的字节数。当有错误发生时则返回-1，错误代码存入errno中！</p>
</li>
<li><p>read()会把参数fd所指的文件传送nbyte个字节到buf指针所指的内存中，成功返回读取的字节数，出错返回-1并设置errno，如果在调read之前已到达文件末尾，则这次read返回0 。</p>
</li>
</ul>
<h3 id="关闭套接字描述符"><a href="#关闭套接字描述符" class="headerlink" title="关闭套接字描述符"></a>关闭套接字描述符</h3><p>close函数用于关闭文件描述符<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">#include &lt;unistd.h&gt;</div><div class="line">int close(int fd);</div></pre></td></tr></table></figure></p>
<p><em>注意：close操作只是让相应socket描述符的引用计数-1，只有引用计数为0的时候，才会触发TCP客户端向服务器端发送终止连接请求</em></p>
<h3 id="基于TCP的socket通信的基本流程"><a href="#基于TCP的socket通信的基本流程" class="headerlink" title="基于TCP的socket通信的基本流程"></a>基于TCP的socket通信的基本流程</h3><ol>
<li>TCP服务器端依次调用socket(),bind(),listen()之后，就会监听指定的socket地址了</li>
<li>TCP客户端依次调用socket(),connect()之后就向TCP服务器端发送一个连接请求</li>
<li>TCP服务器监听到这个请求后，就会调用accept()函数去接受请求，这样连接就建立好了</li>
<li>之后就可以开始网络IO操作了，类似普通文件的读写IO操作</li>
</ol>
<p><img src="https://github.com/songhexiang/windows/blob/master/webbench_song-0.0.1/image/%E5%9F%BA%E4%BA%8ETCP%E7%9A%84socket%E9%80%9A%E4%BF%A1%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B.png" alt="image"></p>
<h3 id="基于UDP的socket通信的基本流程"><a href="#基于UDP的socket通信的基本流程" class="headerlink" title="基于UDP的socket通信的基本流程"></a>基于UDP的socket通信的基本流程</h3><p><img src="https://github.com/songhexiang/windows/blob/master/webbench_song-0.0.1/image/%E5%9F%BA%E4%BA%8EUDP%E7%9A%84socket%E9%80%9A%E4%BF%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B.png" alt="image"></p>
<p>UDP协议面对无连接的通信，所以UDP没有建立连接的过程！<br>创建一个基于udp通信协议的套接字，使用socket函数时第二个参数不能传递SOCK_STREAM,而是传递SOCK_DGRAM<br>比如创建一个基于IPV4地址族的UDP套接字：socket(AF_INET,SOCK_DGRAM,0);<br>通常用于基于UDP协议的IO一般使用recvfrom()和sendto()两个函数进行数据收发。</p>
<p>部分参考： <a href="http://www.cnblogs.com/Lynn-Zhang/p/5716078.html" target="_blank" rel="external">http://www.cnblogs.com/Lynn-Zhang/p/5716078.html</a></p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/C/" rel="tag"># C</a>
          
        </div>
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/04/10/hello-hexo/" rel="prev" title="Hello hexo">
                Hello hexo <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="https://avatars0.githubusercontent.com/u/25613681?v=3&u=2ab2f40fabd733bb5be5055881caba1099fba9a6&s=400"
               alt="Hexiang Song" />
          <p class="site-author-name" itemprop="name">Hexiang Song</p>
           
              <p class="site-description motion-element" itemprop="description">https://github.com/songhexiang/</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">2</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">2</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#学习webbench需要掌握的基础知识（webbench源代码学习心得）"><span class="nav-number">1.</span> <span class="nav-text">学习webbench需要掌握的基础知识（webbench源代码学习心得）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#简述webbench源码思路"><span class="nav-number">1.1.</span> <span class="nav-text">简述webbench源码思路</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#webbench-c"><span class="nav-number">1.1.1.</span> <span class="nav-text">webbench.c</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#关于URL"><span class="nav-number">1.2.</span> <span class="nav-text">关于URL</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#URL实例"><span class="nav-number">1.2.0.1.</span> <span class="nav-text">URL实例</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#http消息的结构"><span class="nav-number">1.3.</span> <span class="nav-text">http消息的结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTP-Request-消息分为3部分"><span class="nav-number">1.3.1.</span> <span class="nav-text">HTTP Request 消息分为3部分</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#request-line实例"><span class="nav-number">1.3.1.1.</span> <span class="nav-text">request line实例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#http-header实例"><span class="nav-number">1.3.1.2.</span> <span class="nav-text">http header实例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#body实例"><span class="nav-number">1.3.1.3.</span> <span class="nav-text">body实例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#关于METHOD中POST和GET方法的区别"><span class="nav-number">1.3.1.4.</span> <span class="nav-text">关于METHOD中POST和GET方法的区别</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTP-Response消息也分为三部分"><span class="nav-number">1.3.2.</span> <span class="nav-text">HTTP Response消息也分为三部分</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#关于getopt-getopt-long参数处理函数"><span class="nav-number">1.4.</span> <span class="nav-text">关于getopt getopt_long参数处理函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#简述"><span class="nav-number">1.4.1.</span> <span class="nav-text">简述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#getopt"><span class="nav-number">1.4.2.</span> <span class="nav-text">getopt</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#getopt-long"><span class="nav-number">1.4.3.</span> <span class="nav-text">getopt_long</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#关于网络IPC-套接字"><span class="nav-number">1.5.</span> <span class="nav-text">关于网络IPC:套接字</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#网络进程间通信：socket-API简介"><span class="nav-number">1.5.1.</span> <span class="nav-text">网络进程间通信：socket API简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#套接字描述符"><span class="nav-number">1.5.2.</span> <span class="nav-text">套接字描述符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#地址格式"><span class="nav-number">1.5.3.</span> <span class="nav-text">地址格式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#将套接字和地址绑定"><span class="nav-number">1.5.3.1.</span> <span class="nav-text">将套接字和地址绑定</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#字节序转换"><span class="nav-number">1.5.4.</span> <span class="nav-text">字节序转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#连接"><span class="nav-number">1.5.5.</span> <span class="nav-text">连接</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数据传输"><span class="nav-number">1.5.6.</span> <span class="nav-text">数据传输</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#关闭套接字描述符"><span class="nav-number">1.5.7.</span> <span class="nav-text">关闭套接字描述符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基于TCP的socket通信的基本流程"><span class="nav-number">1.5.8.</span> <span class="nav-text">基于TCP的socket通信的基本流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基于UDP的socket通信的基本流程"><span class="nav-number">1.5.9.</span> <span class="nav-text">基于UDP的socket通信的基本流程</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Hexiang Song</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Pisces
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  






  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>

  
  <script type="text/javascript" src="/lib/canvas-ribbon/canvas-ribbon.js"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.0"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  


  




	





  





  





  






  





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("17IaRMgYmmmQsf9jVtpSIYmu-gzGzoHsz", "k3UXJpGlFu3bK8YqKaOBLTkl");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  

  

</body>
</html>
